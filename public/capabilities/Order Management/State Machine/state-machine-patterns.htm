<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="Spryker.B2B,Spryker.B2C,Spryker.DemoShop,Spryker.ShopSuite,Spryker.MultiStore">
    <head>
    </head>
    <body>
        <h1>State Machine Patterns <img src="../../../Resources/Images/shoptype/B2B_Shop.png" /> <img src="../../../Resources/Images/shoptype/B2C_Shop.png" /> <img src="../../../Resources/Images/shoptype/MasterSuite.png" /> <img src="../../../Resources/Images/shoptype/Demoshop.png" /></h1>
        <p>
            <MadCap:popup>
                <MadCap:popupHead>MS</MadCap:popupHead>
                <MadCap:popupBody>Multi-store</MadCap:popupBody>
            </MadCap:popup>
        </p>
        <h2>Process Patterns</h2>
        <p MadCap:conditions="General.Hidden Comment">used to be: http://spryker.github.io/oms/state-machine-patterns/</p>
        <p>The State Machine Cook Book describes how to build a state machine with the elements state, transition and event. However there are some recurring design problems that are needed in many processes. In this article common problems and their solution with state machine snippets are described.</p>
        <h3>Process Variants</h3>
        <p>It is a good approach to create a process per payment method and per shipping (drop shiping, cross docking, warehouse) per country.</p>
        <h2>Cross System Orchestration</h2>
        <p>A state machine process describes the entire control flow a sales order/sales order item can follow. This typically includes payment, fulfillment and return processes. The state machine is supposed to orchestrate the entire flow. If you consider the process a relay the baton needs to be handed over to different other systems. Let’s use the example of the fulfillment with an ERP system. At a given point the sales order is ready to be fulfilled. A command can be used to invoke a service from the ERP system that allows to trigger fulfillment for a specific sales order. At that point the ERP system will take over the control and start the pick pack ship process. Zed is passive during this time. It will wait until the ERP system sends an event to inform Zed that the fulfillment is complete. Technically Zed will provide a service that can be called by the ERP system. The service itself needs to identify the Sales Order (correlation) for which this event needs to be fired and then invoke the invokeEvent method from the OMS Facade. Same pattern can be used to do more fine granular status updates. In this case there would be more waiting states and corresponding events that are waited for. See also §4 async response pattern, for timeout and exception management.</p>
        <p>
            <img src="../../../Resources/Images/cross_system_orchestration.png" title="Click me" alt="Cross system orchestration" class="Thumbnail" />
        </p>
        <p MadCap:conditions="General.Image_Source">https://www.gliffy.com/go/html5/10030433</p>
        <h2>Ticket System Integration</h2>
        <p>Most of the sales order processing will be automated. However there are still cases that need human interaction.</p>
        <p>
            <img src="../../../Resources/Images/ticket_system_integration.png" title="Click me" alt="Ticket system integration" class="Thumbnail" />
        </p>
        <p MadCap:conditions="General.Image_Source">https://www.gliffy.com/go/html5/10030517</p>
        <h2>Async Response</h2>
        <p>Everytime the process needs to wait for an async response, this pattern can be applied. The first state indicates that an external service is ready to be invoked. The first transition fires automatically and executes a command that includes the coding to capture the payment in this example. Afterwards a state <var>waiting for result</var> is reached. This shows that the process is waiting for an external event to happen. It is good practice to include the case that the response does not arrive. Therefore a timeout event is bound to an exception transition. This state indicates that the normal flow of the process did not take place. It could be used to open a ticket (see §3). Nevertheless the event could still arrive. Therefore it needs a transition from the <var>timed out</var> state to the <var>capture result received</var> state.</p>
        <p>
            <img src="../../../Resources/Images/async_response.png" title="Click me" alt="Async response" class="Thumbnail" />
        </p>
        <p MadCap:conditions="General.Image_Source">https://www.gliffy.com/go/html5/10030617</p>
        <p>&#160;</p>
        <p><b>See also:</b>
        </p>
        <ul>
            <li><a href="order-process-modelling-state-machines.htm">State Machine Modelling</a>
            </li>
            <li><a href="state-machine-cronjob.htm">Cron Jobs - State Machine</a>
            </li>
            <li><a href="state-machine-events.htm">Triggering Events - State Machine</a>
            </li>
            <li><a href="state-machine-implementing-plugin.htm">Implementing the Plugin - State Machine</a>
            </li>
            <li><a href="state-machine-persistence.htm">Persistence - State Machine</a>
            </li>
            <li><a href="state-machine-persistence.htm">Updating Presentation in Zed - State Machine</a>
            </li>
            <li><a href="http://documentation.spryker.com/state_machine_cookbook/state-machine-cookbook.htm">State Machine cookbook</a>
            </li>
        </ul>
    </body>
</html>