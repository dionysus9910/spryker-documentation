<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="Spryker.B2B,Spryker.B2C,Spryker.DemoShop">
    <head><title>Checkout Steps | Spryker</title>
        <meta name="description" content="This topic provides information about all checkout steps available for the customers." />
    </head>
    <body>
        <h1>Checkout Steps <img src="../../Resources/Images/shoptype/B2B_Shop.png" /> <img src="../../Resources/Images/shoptype/B2C_Shop.png" /> <img src="../../Resources/Images/shoptype/Demoshop.png" /></h1>
        <h2>Entry Step</h2>
        <p>Redirect customer to correct step based on QuoteTransfer state. This step requires <var>input = false</var> so it won’t be rendered.</p>
        <h2>Customer Step</h2>
        <p>The customer step provides three forms:</p>
        <ul>
            <li>login</li>
            <li>register</li>
            <li>register as a guest</li>
        </ul>
        <p>This step is responsible for filling <var>CustomerTransfer</var> with corresponding data. The authentication logic is left to customer module, this step is only delegating calls to (and from) customer module and mapping data with forms.</p>
        <h2>Address Step</h2>
        <p>The address step where customer fills billing and shipping addresses in <var>QuoteTransfer::billing</var> and <var>QuoteTransfer::shipping</var> respectively. This step lets the returning customers to select one of the existing addresses or create a new one. New and guest customers can only create a new address. If a new address is selected, then it’s only created when order is placed in <var>OrderCustomerSavePlugin</var>. This step will be skipped if already signed in customer uses checkout.</p>
        <h2>Shipment Step</h2>
        <p>Get shipment method information and store it into the quote. This step requires additional configuration because different shipment providers and different ways forms should be handled for each.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Form Handling</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p><var>ShipmentForm</var> uses subforms. Each subform is implemented as a plugin that implements <var>CheckoutSubFormInterface</var> and is provided in <var>CheckoutFactory::createShipmentMethodsSubForms()</var>. Main form uses quote transfer as data store. Data for shipment is stored under <var>QuoteTransfer::shipment</var> as a <var>ShipmentTransfer</var> object.</p>
                <p><var>ShipmentTransfer</var> contains:</p>
                <ul>
                    <li class="bullet_list">shipmentSelection (string) — name of the form for the selected shipment.</li>
                    <li class="bullet_list">carrier (ShipmentCarrierTransfer) — includes information on the shipment carrier.</li>
                    <li class="bullet_list">method (ShipmentMethodTransfer) — information about the shipment method that is currently selected.</li>
                </ul>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Data Handling</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Data handling happens after a valid form is being submitted during the <var>ShipmentStep</var>; step receives plugins that implement <var>CheckoutStepHandlerPluginInterface</var> and provided in <var>CheckoutFactory::createShipmentPlugins()</var>. When <var>execute()</var> method is called on <var>ShipmentStep</var> then the plugin that is identified by the <var>ShipmentTransfer::shipmentSelection</var> string is selected and method <var>CheckoutStepHandlerPluginInterface::addToQuote()</var> is called to update <var>QuoteTransfer</var> with payment data. From this part the data handling is left to concrete <var>CheckoutStepHandler</var>.</p>
                <p>The approach of implementing shipment and payment handlers and forms are the same <a href="#payment_step">PaymentStep</a>.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h2><a name="payment_step"></a>Payment Step</h2>
        <p>Get payment information and store it into quote for later processing when state machine is triggered.</p>
        <p>Payment step has similar structure and data handling mechanics as the shipment step does.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Form Handling</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p><var>PaymentForm</var> uses subforms. Each subform is implemented as a plugin that implements <var>CheckoutSubFormPluginInterface</var> and is provided in the <var>CheckoutFactory::createPaymentMethodSubForms()</var>. Main form uses <var>QuoteTransfer</var> as a data store. Data for payment is stored under <var>QuoteTransfer::payment</var> as a <var>PaymentTransfer</var> object.</p>
                <p>Main form has radio buttons, where the customer can select from the available payment methods. Choices are built from the subform name. Each provided subform corresponds to a radio input.</p>
                <p>When the form is created it requires the property path to be provided so that it knows how to map it’s subform to <var>QuoteTransfer</var>. see <a href="http://symfony.com/doc/current/reference/forms/types/form.html#property-path" target="_blank">property_path</a>. Property path is built out of few parts of <var>PaymentTransfer::payment</var> and subform provides <var>getPropertyPath()</var> that returns a string; this string should return the property that exists under <var>PaymentTransfer</var>.</p>
                <p><var>PaymentTransfer</var> includes:</p>
                <ul>
                    <li class="bullet_list">paymentProvider (string) — payment provider name (Paypal, Payolution etc..).</li>
                    <li class="bullet_list">paymentMethod (string) — payment method (credit card, invoice).</li>
                    <li class="bullet_list">paymentSelection (string) — subform name that is currently selected.</li>
                </ul>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Data handling</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Data handling happens after a valid form is submitted during the <var>PaymentStep</var>. The step receives plugins that implement <var>CheckoutStepHandlerPluginInterface</var> and that are provided in the <var>CheckoutFactory::createPaymentPlugins()</var>. When <var>execute()</var> method is called on <var>PaymentStep</var>, the plugin that is identified by <var>PaymentTransfer::paymentSelection</var> string is selected and the <var>CheckoutStepHandlerPluginInterface::addToQuote()</var> is called to update <var>QuoteTransfer</var> with payment data. From this part all population or data handling is left to concrete CheckoutStepHandler.</p>
                <div class="example">A new payment method <var>Paypal</var> must be added. 
				<ol><li>First step would be to add the new property to <var>PaymentTransfer</var> and call it <var>paypal</var>. This property will use <var>PaypalTransfer</var> and it will contain the data we need to map the details from the form.</li><li>Next create/use Paypal module to add step plugin.</li><li>In the Paypal module add the following plugins:
                			<ul><li class="bullet_list">Create <var>PaypalCheckoutSubForm</var> implementing <var>CheckoutSubFormPluginInterface </var>that returns a subform that implements <var>SubFormInterface</var></li><li class="bullet_list">Create <var>PaypalHandler</var> implementing <var>CheckoutStepHandlerPluginInterface</var> that should populate <var>QuoteTransfer:payment:paypal</var> with <var>PaypalTransfer</var></li></ul></li></ol><p>After creation you need to add the plugins to the checkout process.</p><ol><li>To do this you need to create a <var>CheckoutDependencyInjector</var> inside your module and configure it to be used by the Checkout module.
                		<p>From there you can simply inject the needed forms and handler.</p></li><li>Add your form to the <var>CheckoutSubFormPluginCollection</var> by extending the given <var>CheckoutDependencyProvider::PAYMENT_SUB_FORMS</var></li><li>Your handler needs to be added to the <var>CheckoutStepHandlerPluginCollection</var> by extending the given <var>CheckoutDependencyProvider::PAYMENT_METHOD_HANDLER</var></li></ol><p>After this, you should be able to see the new payment selection with subform rendered below.</p></div>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h2>Summary Step</h2>
        <p>Display order information about to be placed item, details and order totals.</p>
        <h2>Place Order Step</h2>
        <p>Place order into system. This step requires <var>input = false</var>. This step makes Zed HTTP request which sends <var>QuoteTransfer</var>. In this step all order saving is happening.</p>
        <h2>Success Page</h2>
        <p>Display success page, on executing, clears <var>QuoteTransfer</var>, also customer session is marked as dirty so that with next request it would reload with updated data (new customer address).</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Checkout Step Interface </MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre xml:space="preserve"><code class="language-PHP line-numbers"> #
  &lt;?php
  interface StepInterface
  {
	/**
	 * Requirements for this step, return true when satisfied.
	 *
	 * @param QuoteTransfer $quoteTransfer
	 *
	 * @return bool
	 */
	public function preCondition(QuoteTransfer $quoteTransfer);
	/**
	 * Require input, should we render view with form or just skip step after calling execute.
	 *
	 * @return bool
	 */
	public function requireInput();
	/**
	 * Execute step logic, happens after form submit if provided, gets QuoteTransfer filled by data from form.
	 *
	 * @param Request $request
	 * @param QuoteTransfer $quoteTransfer
	 *
	 * @return QuoteTransfer
	 */
	public function execute(Request $request, QuoteTransfer $quoteTransfer);
	/**
	 * Conditions that should be met for this step to be marked as completed. returns true when satisfied.
	 *
	 * @param QuoteTransfer $quoteTransfer
	 *
	 * @return bool
	 */
	public function postCondition(QuoteTransfer $quoteTransfer);
	/**
	 * Current step route.
	 *
	 * @return string
	 */
	public function getStepRoute();
	/**
	 * Escape route when preConditions are not satisfied user will be redirected to provided route.
	 *
	 * @return string
	*/
	public function getEscapeRoute();
 }</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step with External Redirect Interface</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers"> #
	&lt;?php
	interface StepWithExternalRedirectInterface extends StepInterface
	{
		/**
		 * Return external redirect url, when redirect occurs not within same application. Used after execute.
		 *
		 * @return string
		 */
		public function getExternalRedirectUrl();
	}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
    </body>
</html>