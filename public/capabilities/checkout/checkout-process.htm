<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="Spryker.B2C,Spryker.B2B,Spryker.DemoShop">
    <head><title>Checkout Process | Spryker</title>
        <meta name="description" content="In order to use checkout in Yves it should be correctly configured and dependencies should be provided." />
    </head>
    <body>
        <h1>Checkout Process <img src="../../Resources/Images/shoptype/B2B_Shop.png" /> <img src="../../Resources/Images/shoptype/B2C_Shop.png" /> <img src="../../Resources/Images/shoptype/Demoshop.png" /></h1>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Checkout Process</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>In order to use checkout in Yves it should be correctly configured and dependencies should be provided. Each step can have a form, a controller action, the implementation of the step logic and Twig template to render the HTML.</p>
                <ul>
                    <li class="bullet_list">Forms - current step form collection.</li>
                    <li class="bullet_list">Controller action - the action that is called when the step is being triggered</li>
                    <li class="bullet_list">Step - a class that implements the <var>StepInterface</var> and handles the data passed through the form.</li>
                    <li class="bullet_list">Twig template - template where form is rendered.</li>
                </ul>
                <p>Each form in the Checkout uses <var>QuoteTransfer</var> for data storage. When the data is being submitted, it’s automatically mapped by the Symfony form component to <var>QuoteTransfer</var>. If the form is valid then the updated <var>QuoteTransfer</var> will be passed to <var>Step::execute()</var> method where you can modify it further or apply custom logic. Also there is Symfony <var>Request</var> object passed if additional/manual data mapping is required.</p>
                <p>There are a few factories provided for checkout dependency wiring:</p>
                <ul>
                    <li class="bullet_list"><var>FormFactory</var> - creates form collections for each step.</li>
                    <li class="bullet_list"><var>StepFactory</var> - creates the steps together with their dependencies and plugins.</li>
                    <li class="bullet_list"><var>CheckoutFactory</var> - where the <var>StepProcess</var> is created for all steps.</li>
                </ul>
                <p>We have a step process which contains the list of the steps created. The <var>CheckoutProcess::process(Request, FormCollectionHandlerInterface)</var> process method accepts a Request which is currently submitted and a <var>FormCollectionHandlerInterface</var> implementation that contains the list of forms that are used in the current step. If there are multiple forms that are used, <var>FormCollectionHandler</var> selects the right one when request is being made.</p>
                <p>Some forms need external data provided, for this purpose there is <var>DataProviderInterface</var>, each implementor must provide data, for select or form itself. This data provider is passed when FormCollection is created. When handle method is called FormCollection handler creates form types and feeds data from data provider.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Checkout Quote Transfer Lifetime </MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>
                    <img src="../../Resources/Images/quote_transfer_lifetime.png" title="Click Me" alt="Quote transfer lifetime" class="Thumbnail">
                    </img>
                </p>
                <p>When a process is being called on <var>StepProcess,</var> it will try to get the current valid step by walking through the step stack and calling the <var>postCondition()</var> for each, starting from the first in the stack. If <var>postCondition()</var> is being called on <var>StepProcess</var>, it will try to get the current valid step by walking through the step stack and calling the <var>postCondition()</var> for each, starting from the first in the stack. If <var>postCondition()</var> failed, then this step will be used for later processing. After that, the view variables with <var>QuoteTransfer</var> and form are passed to Twig and the HTML is rendered.</p>
                <h2>Post Condition</h2>
                <p>Post condition is an important part of the step Processing. Basically, this post condition indicates if a step has all the data that it needs and if its requirements are satisfied. It’s not possible to access next step from stack if previous step post conditions are not met, but it’s possible to navigate to any step where post conditions are satisfied (<var>return true</var>).</p>
                <p>Post conditions are called twice per step processing:</p>
                <ul>
                    <li class="bullet_list">To find the current step or if we can access the current step.</li>
                    <li class="bullet_list">After <var>execute()</var>, to make sure the step was completed and that we can continue to next step.</li>
                </ul>
                <h2>Post Condition Error Route </h2>
                <p>Inside your step you can set a post condition error route. If you need to redirect to another error route than the one specified during the step construction.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>How the Quote Transfer is Mapped Inside Forms</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Symfony forms provide a mechanism to store data into objects without having the need of a manual mapping. It’s called <a href="http://symfony.com/doc/current/cookbook/form/data_transformers.html" target="_blank">Data transformers</a>. There are a few important things to make this work. Because we are passing the entire <var>QuoteTransfer</var>, the form handler does not know which fields are you trying to use. Symfony provides few ways to handle this situation:</p>
                <ul>
                    <li class="bullet_list">using <a href="http://symfony.com/doc/current/reference/forms/types/form.html#property-path" target="_blank">property_path</a> configuration directive<br></br>It uses the full path to object property you are about to map form into, for example <var>payment.paypal</var> will map your form to <var>QuoteTransfer:payment:paypal</var>; this works when the property is not on the same level and when you are using subforms.</li>
                    <li class="bullet_list">Another approach is using a main form that includes subforms. Each subform has to be configured with <var>data_class</var> option that is the FQCN of transfer object you are about to use. This works when property is in the top level.</li>
                </ul>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Checkout Form Submission </MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>On form submission, the same processing starts with the difference that if form submit is detected then the validation is called:</p>
                <ul>
                    <li class="bullet_list">if the form is invalid then view will be rendered with validation errors</li>
                    <li class="bullet_list">if form data is valid, then <var>execute()</var> is called on step that executes the step related logic.</li>
                </ul>
                <p>E.g.: add address to QuoteTransfer or get payment details from Zed, call external service etc.</p>
                <p>It’s up to you to decide what to do in each execute method. It’s important that after <var>execute()</var> runs, the updated returned <var>QuoteTransfer</var> should satisfy the <var>postCondition(</var>) so that the <var>StepProcess</var> can take another step from the stack.</p>
                <h2>Required Input </h2>
                <p>Normally each step requires an input from the customer. But there are cases when there is no need to render a form or a view but some processing is still required (e.g. <var>PlaceOrderStep</var>, <var>EntryStep</var>). Each step should provide the implementation of the <var>requireInput()</var> method. <var>StepProcess </var>will call this method and react accordingly. Again if <var>requireInput()</var> is false, then after running <var>execute()</var> the postConditions should be satisfied.</p>
                <h2>Precondition and Escape Route </h2>
                <p>Preconditions are called before each step; this is a check to indicate that step can’t normally be processed.</p>
                <p>E.g.: the cart is empty. If the <var>preCondition()</var> return false, then customer is redirected to the escapeRoute provided when configuring the step.</p>
                <h2>External Redirect URL </h2>
                <p>Sometimes it’s needed to redirect the customer to an external URL (outside application). The step should implement <var>StepWithExternalRedirectInterface::getExternalRedirectUrl()</var> which returns the URL to redirect customer after <var>execute()</var> is ran.</p>
                <p class="important">Each step must implement StepInterface.</p>
                <p>
                    <img src="../../Resources/Images/step_flow.png" title="Click Me" alt="Step Flow" class="Thumbnail" />
                </p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Placing the Order</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>After the customer clicks the submit button during the <var>SummaryStep</var>, the <var>PlaceOrderStep</var> is started. This step takes the <var>QuoteTransfer</var> and starts the checkout workflow to store the order into the system. Zed Checkout module contains a number of plugins where you can add additional behavior, check preconditions, save or execute post condition check.</p>
                <h2 MadCap:conditions="General.Hidden Comment">Workflows</h2>
                <p MadCap:conditions="General.Hidden Comment">Since <MadCap:annotation MadCap:createDate="2018-12-26T13:07:29.1652276+02:00" MadCap:creator="oksana.karasyova" MadCap:initials="OK" MadCap:comment="Update module version after https://spryker.atlassian.net/browse/PS-476 is released" MadCap:editor="oksana.karasyova" MadCap:editDate="2018-12-26T13:07:47.4107662+02:00">Checkout 4.2.</MadCap:annotation>0 it's possible to define multiple checkout workflows with separate sets of plugins to allow order placement in other way than regular checkout (e.g. importing order from external system).</p>
                <h2><a name="Plugins"></a>Plugins</h2>
                <p>Zed's Checkout module contains four types of plugins to extend the behavior on placing an order. Any plugin has access to <var>QuoteTransfer</var> that is supposed to be read only and <a href="#checkout_response_transfer">CheckoutResponseTransfer</a> data object that can be modified.</p>
                <ul>
                    <li class="bullet_list">PreCondition — is for checking if the order satisfies predefined constraints (e.g., if the quantity of items is still available).</li>
                    <li class="bullet_list">OrderSavers — is for saving order, each plugin is responsible for saving certain parts of the order (sales module saves items, discount module saves discounts, product option module saves options etc..). Each <var>OrderSaver</var> plugin is wrapped into a single transaction; if exception is being thrown, transaction will be rolledback.</li>
                    <li class="bullet_list">CheckPostConditions — is for checking conditions after saving, last time to react if something did not happen by the plan. It’s called after state machine execution.</li>
                    <li>
                        <p>PostSaveHook — is called after order placement, sets the success flag to false, if redirect should be headed to an error page afterwards.</p>
                    </li>
                </ul>
                <h2><a name="checkout_response_transfer"></a>Checkout Response Transfer</h2>
                <ul>
                    <li class="bullet_list">isSuccess (bool) — indicates if the checkout process was successful.</li>
                    <li class="bullet_list">errors (<a href="#checkout_error_transfer">CheckoutErrorTransfer</a>) — list of errors that occurred during execution of the plugins.</li>
                    <li class="bullet_list">isExternalRedirect (bool) — specifies if the redirect, that happens after the order was placed successfully, is external.</li>
                    <li class="bullet_list">redirectUrl (string) — URL to redirect customer after the order was placed successfully.</li>
                    <li class="bullet_list">saveOrder (<a href="#save_order_transfer">SaveOrderTransfer</a>) — stores ids of the items that OrderSaver plugins have saved.</li>
                </ul>
                <h2><a name="checkout_error_transfer"></a>Checkout Error Transfer</h2>
                <ul>
                    <li class="bullet_list">errorCode (int) — numeric error code. The checkout error codes are listed below.</li>
                    <li class="bullet_list">message (string) — error message.</li>
                </ul>
                <h2><a name="checkout_error_codes"></a>Checkout Error Codes</h2>
                <ul>
                    <li class="bullet_list">4001 — customer email already used.</li>
                    <li class="bullet_list">4002 — product unavailable.</li>
                    <li class="bullet_list">4003 — cart amount does not match.</li>
                    <li class="bullet_list">5000 — unknown error.</li>
                </ul>
                <h2><a name="save_order_transfer"></a>Save Order Transfer</h2>
                <ul>
                    <li class="bullet_list">idSalesOrder (int) — ID of the current saved order.</li>
                    <li class="bullet_list">orderReference (string) — auto generated ID of the order.</li>
                    <li class="bullet_list">orderItems (ItemTransfer) — saved order items.</li>
                </ul>
                <p>There are already some plugins implemented with each of those types:</p>
                <h2>Precondition Plugins</h2>
                <ul>
                    <li class="bullet_list"><var>CustomerPreConditionCheckerPlugin</var> — Checks if the email of the customer is already used.</li>
                    <li class="bullet_list"><var>ProductsAvailableCheckoutPreConditionPlugin </var>— Check if the items contained in the cart are in stock.</li>
                </ul>
                <h2>Postcondition Plugins</h2>
                <ul>
                    <li class="bullet_list"><var>OrderCustomerSavePlugin</var> — save/create customer in database if the customer is new or the ID is not set (guest customer is ignored).</li>
                    <li class="bullet_list"><var>SalesOrderSaverPlugin</var> — saves order information, creates sales_order and sales_order_item table.</li>
                    <li class="bullet_list"><var>ProductOptionOrderSaverPlugin</var> — saves product options to sales_product_item table.</li>
                    <li class="bullet_list"><var>DiscountOrderSavePlugin</var> — save order discounts to sales_discounts table.</li>
                    <li class="bullet_list"><var>OrderShipmentSavePlugin</var> — saves order shipment information to sales_expense table.</li>
                </ul>
                <h2>Pre Save Condition Plugin</h2>
                <ul>
                    <li><var>SalesOrderExpanderPlugin</var> — expands items by quantity and recalculate quote.</li>
                </ul>
                <h2>State Machine</h2>
                <p>State machine is triggered in the <var>CheckoutWorkflow</var> class from the Checkout module; the execution starts after pre-condition and order saver plugins store no errors into <a href="#checkout_response_transfer">CheckoutResponseTransfer</a>.</p>
                <p>The state machine trigger needs a name in order to be executed. The name is set by <var>SalesOrderSaverPlugin</var> in the Sales module. Each project has to implement <var>SalesConfig::determineProcessForOrderItem()</var> method, which should return the state machine name for the selected order item. E.g.: Payolution payment would return PayolutionPayment01.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
    </body>
</html>
