<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="Spryker.B2B,Spryker.B2C">
    <head><title>Search 3.0</title>
    </head>
    <body>
        <h1>Search 3.0 <img src="../../Resources/Images/shoptype/B2B_Shop.png" /> <img src="../../Resources/Images/shoptype/B2C_Shop.png" /></h1>
        <p>
            <MadCap:relatedTopics target="_self" style="mc-label: 'Versions';mc-help-control-display: list;">
                <MadCap:relatedTopic src="search-4-0.htm" />
                <MadCap:relatedTopic src="search.htm" />
            </MadCap:relatedTopics>
        </p>
        <p class="important">The latest version of this module can be found in <MadCap:xref href="search.htm">Search</MadCap:xref> section</p>
        <p>One of the most important features in an e-commerce application is to give the customer the ability to find the products that he needs. Depending on how easy it is to find the products the customer is searching for and how relevant the search results are, the search feature is a crucial aspect for an e-commerce business.</p>
        <p>Spryker provides a fully functional solution to integrate <var>Elasticsearch</var> as a search engine. You can extend this solution or customize it to fit for your needs.</p>
        <p>Spryker uses <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a> version 2.x.</p>
        <p>We’ll have a look on how to configure and use the <var>Search</var> module:</p>
        <ul>
            <li>Configure Elasticsearch</li>
            <li>Search Collector Configuration</li>
            <li>Search Query</li>
            <li>Configure Search Features</li>
        </ul>
        <h2>Configure Elasticsearch</h2>
        <p>Elasticsearch is a <var>NoSQL</var> data store which allows us to predefine the structure of the data we’ll be storing in it.</p>
        <p>Since the data structure we use is static, we would like to define it in advance. The definitions of the indexes and mapping types are written in <var>JSON</var> format, just like you’ll find it in the <var>Elasticsearch</var> documentation.</p>
        <p>The content of the configuration files needs to follow the conventions of the official <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html" target="_blank">Elasticsearch index creation</a> documentation. Note that the current search installer support only settings and mappings but if you need more, feel free to extend it on project level.</p>
        <p class="info"><strong>Default Schema</strong>
            <br />You can find the default schema configuration file at <var>vendor/spryker/search/src/Spryker/Shared/Search/IndexMap/search.json</var>.<br /></p>
        <p class="info">If you want to disable the installation of the default mapping, you need to override the core configuration defined in <var>\Spryker\Zed\Search\SearchConfig::getJsonIndexDefinitionDirectories()</var> by implementing it on the project level (e.g. <var>Pyz\Zed\Search\SearchConfig</var>).<br /></p>
        <p>Each configured store will have its own index installed automatically. The name of the indexes are composed from store name + underscore + configuration file name (e.g.: <var>de_search</var>).</p>
        <h3>Defining New Indexes and Mapping Types</h3>
        <p>You can define new indexes and mapping types by creating new configuration files under the <var>Shared</var> namespace of any module.</p>
        <p>Example:</p>
        <ul>
            <li><var>src/Shared/MyBundleName/IndexMap/myindex.json</var>
            </li>
        </ul>
        <p>You are able to extend or overwrite existing configurations by creating a new file with the same name you wish to modify and provide only the differences compared to the original one.</p>
        <p>When the search installer runs, it will first read all the available configuration files and merge them by index name per each store. This might be handy if you have bundles which are not tightly coupled together but both need to use the same index for some reason or you just need to extend or override the default configuration provided on the Core level.</p>
        <p>It’s also possible to extend or modify indexes and mapping types for specific stores. All you need to do is to create a new configuration file along with the name of the store (e.g. <var>de_search.json</var>) and it will be only used for that store. For example, you might have different analyzing strategy for your stores, so you’ll need to define it separately.</p>
        <h3>Installing Indexes and Mapping Types</h3>
        <p>Execute the following command to run the installation process:</p><pre><code class="language-PHP line-numbers">vendor/bin/console setup:search</code></pre>
        <p>This will install indexes which are not yet created and <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-put-mapping.html" target="_blank" title="Elasticsearch mapping types" alt="Elasticsearch mapping types">update the mapping types</a> based on the <var>JSON</var> configurations.</p>
        <p>Note that if an index is created with the given settings, it won’t be changed by running this process, but the mapping can be modified and will be changed.</p>
        <p>In development environment, if you need to create new analyzers or change the index settings, you need to delete the index first and run the install process again.</p>
        <p>When you run the search installer for every mapping type, a helper class will be auto-generated. You can find these classes under the \Generated\Search\IndexMap namespace. The name of the generated class starts with the name of the mapping type and is suffixed with IndexMap.</p>
        <p>For the default page mapping type, the class is <var>\Generated\Search\IndexMap\PageIndexMap</var>.</p>
        <p>These classes provides some information from the mapping type, such as the fields and the meta data. Use these classes for references when you need to program against something related to the schema of that mapping type.</p>
        <p>If you change a mapping type and run the installer, the auto-generated classes will also change accordingly.</p>
        <h2>Search Collector Configuration</h2>
        <p>In this section you’ll learn how to easily map collected data from the database to the default Elasticsearch <i>page</i> mapping type.</p>
        <p>For more on for more on how collectors work in general, see <MadCap:xref href="../Development/Collector/collector.htm">Collector</MadCap:xref>.</p>
        <p>First, you need to implement <var>\Spryker\Zed\Search\Dependency\Plugin\PageMapInterface</var> interface in the desired module of your project as a plugin. This interface contains the <var>buildPageMap()</var> method which will be called for each collected document and its responsibility is to create a <var>PageMapTransfer</var> object and fill it with the mapped data. Basically this transfer object represents one document in the page type.</p>
        <p>The <var>buildPageMap()</var> method provides an instance of <var>\Spryker\Zed\Search\Business\Model\Elasticsearch\DataMapper\PageMapBuilderInterface</var> to help to fill this transfer object with the correct data in the correct format. It’s really easy to use, all you need to do is to tell the <i>PageMapBuilder</i> which data you need to have in the search result data, which data you want to filter by, which data you want to sort by, etc.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php

/**
     * @param \Spryker\Zed\Search\Business\Model\Elasticsearch\DataMapper\PageMapBuilderInterface $pageMapBuilder
     * @param array $productData
     * @param \Generated\Shared\Transfer\LocaleTransfer $locale
     *
     * @return \Generated\Shared\Transfer\PageMapTransfer
     */
    public function buildPageMap(PageMapBuilderInterface $pageMapBuilder, array $productData, LocaleTransfer $locale)
    {
        $pageMapTransfer = (new PageMapTransfer())
            -&gt;setStore(Store::getInstance()-&gt;getStoreName())
            -&gt;setLocale($locale-&gt;getLocaleName());

        $price = $this-&gt;getPriceBySku($productData['abstract_sku']);

        $pageMapBuilder
            -&gt;addSearchResultData($pageMapTransfer, 'id_product_abstract', $productData['id_product_abstract'])
            -&gt;addSearchResultData($pageMapTransfer, 'abstract_sku', $productData['abstract_sku'])
            -&gt;addSearchResultData($pageMapTransfer, 'abstract_name', $productData['abstract_name'])
            -&gt;addSearchResultData($pageMapTransfer, 'price', $price)
            -&gt;addSearchResultData($pageMapTransfer, 'url', $this-&gt;getProductUrl($productData))
            -&gt;addSearchResultData($pageMapTransfer, 'available', $this-&gt;isAvailable($productData)
            -&gt;addFullTextBoosted($pageMapTransfer, $productData['abstract_name'])
            -&gt;addSuggestionTerms($pageMapTransfer, $productData['abstract_name'])
            -&gt;addCompletionTerms($pageMapTransfer, $productData['abstract_name'])
            -&gt;addStringSort($pageMapTransfer, 'name', $productData['abstract_name'])
            -&gt;addIntegerSort($pageMapTransfer, 'price', $price)
            -&gt;addIntegerFacet($pageMapTransfer, 'price', $price)
            -&gt;addCategory($pageMapTransfer, $this-&gt;getAllParentCategories($productData), $this-&gt;getDirectParentCategories($productData));

        return $pageMapTransfer;
				}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>In the example above you can see that first we create the <var>PageMapTransfer</var> instance, add some metadata to it, then with the help of the <var>PageMapBuilderInterface</var> we can easily map some data to the transfer.</p>
        <p>At the end, we’ll get the data for a document similar to the example below:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">{
   "store": "DE",
   "locale": "en_US",
   "search-result-data": {
      "id_product_abstract": 1,
      "abstract_sku": "foo",
      "abstract_name": "Lorem ipsum",
      "url": "/lorem-ipsum",
      "price": 1234,
      "available": true
   },
   "full-text-boosted": [
      "Lorem ipsum"
   ],
   "suggestion-terms": [
      "Lorem ipsum"
   ],
   "completion-terms": [
      "Lorem ipsum"
   ],
   "string-sort": {
      "name": "Lorem ipsum"
   },
   "integer-sort": {
      "price": 1234
   },
   "integer-facet": [
      {
         "facet-name": "price",
         "facet-value": 1234
      }
   ],
   "category": {
      "direct-parents": [
         "1"
      ],
      "all-parents": [
         "1",
         "2",
         "3"
      ]
   }
}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>After implementing our <i>PageMap</i> plugin we need to make sure that we also use it in our collector.</p>
        <p>The collector has the <var>collectItem()</var> method which has the data for our <i>PageMap</i> plugin to generate the <var>PageMapTransfer</var>. The <var>collectItem()</var> by definition needs to return an array which is exactly the final data for one document pushed to <var>Elasticsearch</var>.</p>
        <p>To transform the generated <var>PageMapTransfer</var> into the final document in the right format, use the <var>transformPageMapToDocument()</var> method of the <var>SearchFacade</var>.</p>
        <p>In the example below you can see how the <i>PageMap</i> plugin is used in the <var>ProductCollector</var> from Demoshop.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Collector\Business\Search;

use Spryker\Zed\Collector\Business\Collector\Search\AbstractSearchPdoCollector;
use Spryker\Zed\Search\Business\SearchFacadeInterface;
use Spryker\Zed\Search\Dependency\Plugin\PageMapInterface;

class ProductCollector extends AbstractSearchPdoCollector
{

    /**
     * @var \Spryker\Zed\Search\Dependency\Plugin\PageMapInterface
     */
    protected $productDataPageMapPlugin;

    /**
     * @var \Spryker\Zed\Search\Business\SearchFacadeInterface
     */
    protected $searchFacade;

    /**
     * @param \Spryker\Zed\Search\Dependency\Plugin\PageMapInterface $productDataPageMapPlugin
     * @param \Spryker\Zed\Search\Business\SearchFacadeInterface $searchFacade
     */
    public function __construct(PageMapInterface $productDataPageMapPlugin, SearchFacadeInterface $searchFacade)
    {
        $this-&gt;productDataPageMapPlugin = $productDataPageMapPlugin;
        $this-&gt;searchFacade = $searchFacade;
    }

    /**
     * @param string $touchKey
     * @param array $collectItemData
     *
     * @return array
     */
    protected function collectItem($touchKey, array $collectItemData)
    {
        return $this
            -&gt;searchFacade
            -&gt;transformPageMapToDocument($this-&gt;productDataPageMapPlugin, $collectItemData, $this-&gt;locale);
    }

}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h3>Dynamic Product Attribute Mapping</h3>
        <p>Product attributes can be changed in time, when for example a shop decides to add a few new types of products to the catalogue.</p>
        <p>As we saw earlier, it’s possible to configure which data you provide for Elasticsearch. It also can be applied for product attributes, but it’s not too effective that developers need to take care of them if they are changing a lot.</p>
        <p>For this reason, the <i>ProductSearch</i> module </p>
        <p>provides an extra feature that allows you to dynamicaly map product attributes to the documents for Elasticsearch page type.</p>
        <p>In the database there is a <var>spy_product_search_attribute_map</var> table that contains two fields:</p>
        <ul>
            <li><var>fk_product_attributes_metadata</var> which is the foreign key of the product attribute</li>
            <li><var>target_field</var> which is a string, representing the field name from the Elasticsearch <i>page</i> type.</li>
        </ul>
        <p>If you feed this table with data (by building a UI in Zed, or in any other way) you can easily extend the previously implemented <var>buildPageMap()</var> method by calling <i>ProductSearchFacade’s</i> <var>mapDynamicProductAttributes()</var> at the end.</p>
        <p>So let’s extend our previous example of <var>buildPageMap()</var>.</p><pre><code class="language-PHP line-numbers">&lt;?php

	/**
     * @param \Spryker\Zed\Search\Business\Model\Elasticsearch\DataMapper\PageMapBuilderInterface $pageMapBuilder
     * @param array $productData
     * @param \Generated\Shared\Transfer\LocaleTransfer $locale
     *
     * @return \Generated\Shared\Transfer\PageMapTransfer
     */
    public function buildPageMap(PageMapBuilderInterface $pageMapBuilder, array $productData, LocaleTransfer $locale)
    {
        // ...

        $pageMapTransfer = $this
            -&gt;productSearchFacade
            -&gt;mapDynamicProductAttributes($pageMapBuilder, $pageMapTransfer, $attributes);

        return $pageMapTransfer;
    }</code></pre>
        <p class="info"><strong>Zed UI for product attribute mapping</strong>
            <br />It's in Spryker's pipeline to provide an easy to use Zed UI for product dynamic attribute mapping.<br /></p>
        <h2>Search Query</h2>
        <p>Now we have all necessary data in Elasticsearch, it’s time to display them in <i>Yves</i>.</p>
        <p>In order to achieve this, we first need to query Elasticsearch, which will return raw data for us that we need to process and prepare to display it in our templates.</p>
        <p>In the <var>SearchClient</var> you can find the <var>search()</var> method (<var>\Spryker\Client\Search\SearchClientInterface::search()</var>).</p>
        <p>This is the method that you need to call to execute any search query. It expects to receive an instance of <var>\Spryker\Client\Search\Dependency\Plugin\QueryInterface</var> as first parameter, which represents the query itself, and a collection of <var>\Spryker\Client\Search\Dependency\Plugin\ResultFormatterPluginInterface</var> instances which will be applied on the response data to format it.</p>
        <h3>Querying Elasticsearch</h3>
        <p>The first thing we need to do is to implement the QueryInterface. To communicate with Elasticsearch. Spryker uses the <a href="http://elastica.io/" target="_blank" title="Elastica" alt="Elastica">Elastica</a> library as a Data Query Language.</p>
        <p>Inside the <var>QueryInterface</var> you need to create an instance of <var>\Elastica\Query</var>, configure it to fit your needs, then return it with <var>getSearchQuery()</var>.</p>
        <p>This is the point where configuring the query is completely up to you, use Elastica to alter the query for your needs, add filters, aggregations, boosts, sorting, pagination or anything else you like and Elasticsearch enables you.</p>
        <p class="info">The <var>QueryInterface</var> instance is a stateful class; sometimes <var>getSearchQuery()</var> method is called multiple times and alters the original query (see: Expandig queries), so you need to make sure that it returns the same instance. This can be achieved by creating the <var>\Elastica\Query</var> instance at construction time and just return it in the getSearchQuery() method.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Client\Catalog\Plugin\Query;

use Elastica\Query;
use Elastica\Query\MatchAll;
use Generated\Shared\Search\PageIndexMap;
use Spryker\Client\Kernel\AbstractPlugin;
use Spryker\Client\Search\Dependency\Plugin\QueryInterface;

class MatchAllQueryPlugin extends AbstractPlugin implements QueryInterface
{

    /**
     * @var \Elastica\Query
     */
    protected $query;

    /**
     * @param string $searchString
     */
    public function __construct()
    {
        $this-&gt;query = $this-&gt;createSearchQuery();
    }

    /**
     * @return \Elastica\Query
     */
    public function getSearchQuery()
    {
        return $this-&gt;query;
    }

    /**
     * @return \Elastica\Query
     */
    protected function createSearchQuery()
    {
        $query = new Query();
        $query = $this-&gt;addMatchAllQuery($query);
        $query-&gt;setSource([PageIndexMap::SEARCH_RESULT_DATA]);

        return $query;
    }

    /**
     * @param \Elastica\Query $baseQuery
     *
     * @return \Elastica\Query
     */
    protected function addMatchAllQuery(Query $baseQuery)
    {
        $baseQuery-&gt;setQuery(new MatchAll());

        return $baseQuery;
    }

}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>In the example above, a simple query is created, which will return all the documents from our mapping type.</p>
        <p>To execute this query you need to call the <var>search()</var> method of the <var>SearchClient</var>.</p>
        <h3>Expanding Queries</h3>
        <p>Query expanders are a way to reuse query parts for multiple queries.</p>
        <p>The suggested way to create queries is to create the minimum possible query as a base query for your use case, then use query expanders to expand it with other reusable behaviours, such as pagination, sorting, etc.</p>
        <p>You can create a new expander by implementing <var>\Spryker\Client\Search\Dependency\Plugin\QueryExpanderPluginInterface</var>.</p>
        <p>Again, if you use query expanders, make sure that your base query is expandable, so it provides the same instance by calling <var>getSearchQuery()</var> multiple times.</p>
        <p>To expand a base query with a collection of expanders, you’ll need to use <var>expandQuery()</var> method from the <var>SearchClient</var>.</p><pre><code class="language-PHP line-numbers">&lt;?php
	// ...

    /**
     * @var \Spryker\Client\Search\SearchClientInterface
     */
    protected $searchClient;

    // ...

    /**
     * @param \Spryker\Client\Search\Dependency\Plugin\QueryInterface $baseQuery
     * @param \Spryker\Client\Search\Dependency\Plugin\QueryExpanderPluginInterface[] $queryExpanders
     * @param array $requestParameters
     *
     * @return \Spryker\Client\Search\Dependency\Plugin\QueryInterface
     */
    protected function expandBaseQuery(QueryInterface $baseQuery, array $queryExpanders, array $requestParameters)
    {
        $searchQuery =  $this
            -&gt;searchClient
            -&gt;expandQuery($baseQuery, $queryExpanders, $requestParameters);

        return $searchQuery;
    }

    // ...</code></pre>
        <p>At the moment, Spryker contains three query expander plugins that provide frequently used features.</p>
        <p>They are all optional for use, you need to decide for which of your query you would like to use what query expanders.</p>
        <h3>Faceted Navigation and Filters</h3>
        <p>The first query expander plugin is the <var>\Spryker\Client\Search\Plugin\Elasticsearch\QueryExpander\FacetQueryExpanderPlugin</var>. It’s responsibility to add the necessary aggregations to your query based on a predefined configuration (see: Configure search features section below). You can use this plugin to get the necessary data for faceted navigation of your search results. If you use this plugin also make sure to add the <var>\Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\FacetResultFormatterPlugin</var> to your result formatter collection, which takes care of processing the returned raw aggregation data.</p>
        <h3>Paginating the Results</h3>
        <p>The next <i>query expander plugin</i> is the <var>\Spryker\Client\Search\Plugin\Elasticsearch\QueryExpander\PaginatedQueryExpanderPlugin</var>. It takes care of paginating your results based on the predifined configuration. If you use this plugin also make sure to add the <var>\Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\PaginatedResultFormatterPlugin</var> to your result formatter collection.</p>
        <h3>Sorting the Results</h3>
        <p>The last <i>query expander plugin</i> is the <var>\Spryker\Client\Search\Plugin\Elasticsearch\QueryExpander\SortedQueryExpanderPlugin</var>. It takes care of sorting your results based on the predefined configuration. The necessary result formatter for this plugin is <var>\Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\SortedResultFormatterPlugin</var></p>
        <h3>Process Query Result</h3>
        <p>After you’ve created your query, you also need to take care of processing the raw response from <var>Elasticsearch</var>. This is done by providing a collection of <var>\Spryker\Client\Search\Dependency\Plugin\ResultFormatterPluginInterface</var>.</p>
        <p>To create one you need to extend <var>\Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\AbstractElasticsearchResultFormatterPlugin</var></p>
        <p>It’s also possible to not provide any result formatters; in this case the raw response will be returned at the end.</p><pre><code class="language-PHP line-numbers">&lt;?php

namespace Pyz\Client\Catalog\Plugin\ResultFormatter;

use Elastica\Result;
use Elastica\ResultSet;
use Generated\Shared\Search\PageIndexMap;
use Spryker\Client\Search\Plugin\Elasticsearch\ResultFormatter\AbstractElasticsearchResultFormatterPlugin;

class DummyResultFormatterPlugin extends AbstractElasticsearchResultFormatterPlugin
{

    const NAME = 'test';

    /**
     * @return string
     */
    public function getName()
    {
        return static::NAME;
    }

    /**
     * @param \Elastica\ResultSet $searchResult
     * @param array $requestParameters
     *
     * @return array
     */
    protected function formatSearchResult(ResultSet $searchResult, array $requestParameters)
    {
        $results = [];

        foreach ($resultSet-&gt;getResults() as $result) {
            $results[] = $this-&gt;formatResult($result);
        }

        return $results;
    }

    /**
     * @param \Elastica\Result $result
     *
     * @return mixed
     */
    protected function formatResult(Result $result)
    {
        // Do something with the result ...
        return $result;
    }

}</code></pre>
        <p>To execute the previously created query along with this result formatter plugin, you need to call the <var>search()</var> method of the <var>SearchClient</var> and provide this formatter to its second parameter.</p>
        <p>When you use result formatter plugins, the result of the <var>SearchClient::search()</var> method will be an associative array, where the keys are the name of each result formatters (provided by <var>getName()</var> method) and the values are the response for each result formatter.</p>
        <p>This way in your controller where at the end you get the response you can simply provide everything you got right to the template to care of.</p>
        <h2>Configure Search Features</h2>
        <p>In this section you’ll learn how to configure faceted navigation, filters, pagination and sorting, so all the important search features that are provided by the <var>Search</var> module.</p>
        <p>This configuration is only relevant if you enable the three query expanders and result formatters mentioned above.</p>
        <p>Indirectly, they all require you to provide an instance of <var>\Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterface</var> by <var>\Spryker\Client\Search\SearchDependencyProvider::createSearchConfigPlugin()</var> method. So first of all you’ll need to implement this interface.</p><pre><code class="language-PHP line-numbers">&lt;?php

namespace Pyz\Client\Catalog\Plugin\Config;

use Spryker\Client\Kernel\AbstractPlugin;
use Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterface;

/**
 * @method \Spryker\Client\Catalog\CatalogFactory getFactory()
 */
class CatalogSearchConfigBuilder extends AbstractPlugin implements SearchConfigBuilderInterface
{
    // ...
}</code></pre>
        <p>The first method we’ll implement in this interface is <var>buildFacetConfig()</var> where we configure our facet filters.</p>
        <p>The goal here is to create <var>FacetConfigTransfer</var> instances with some data and push them for the <var>$facetConfigBuilder</var>.</p>
        <p>Let’s assume that previously in our <var>PageMapInterface</var> we mapped an integer facet which we called “price” with some data (note the use of <var>addIntegerFacet()</var> in the example above), so now we would like to add a price range filter for that data.</p><pre><code class="language-PHP line-numbers">&lt;?php

namespace Pyz\Client\Catalog\Plugin\Config;

use Generated\Shared\Transfer\FacetConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ...

    /**
     * @param \Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface $facetConfigBuilder
     *
     * @return void
     */
    public function buildFacetConfig(FacetConfigBuilderInterface $facetConfigBuilder)
    {
        $priceFacet = (new FacetConfigTransfer())
            -&gt;setName('price')
            -&gt;setParameterName('price')
            -&gt;setFieldName(PageIndexMap::INTEGER_FACET)
            -&gt;setType(FacetConfigBuilder::TYPE_PRICE_RANGE);

        $facetConfigBuilder-&gt;addFacet($priceFacet);
    }

// ...</code></pre>
        <p>You could create and add as many <var>FacetConfigTransfers</var> as you need. Let’s analyze this transfer’s options below:</p>
        <ul>
            <li><strong>setName()</strong>: <i>Required</i> field, the name of the target data to filter by.</li>
            <li><strong>setParameterName()</strong>: <i>Required</i> field, the name that will be used in the request when the filter is used.</li>
            <li><strong>setFieldName()</strong>:<i> Required</i> field, the name of the field of the page mapping type where the target data is stored.</li>
            <li><strong>setType()</strong>: <i>Required</i> field, the type of the facet. Currently available options: “enumeration”, “bool”, “range”, “price_range”, “category”.</li>
            <li><strong>setIsMultiValued()</strong>: <i>Optional</i> field, if set to <var>true</var> multiple values can be filtered with logical OR comparison.</li>
        </ul>
        <p>The next method we’ll implement is the <var>buildSortConfig()</var>, where we configure our sorting options. Let’s assume we’d like to sort by name and price and we’ve already added them when we implemented <var>PageMapInterface</var> (note the use of <var>addStringSort()</var> and <var>addIntegerSort()</var> in the example above).</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php

namespace Pyz\Client\Catalog\Plugin\Config;

use Generated\Shared\Transfer\SortConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ...

    /**
     * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder
     *
     * @return void
     */
    public function buildSortConfig(SortConfigBuilderInterface $sortConfigBuilder)
    {
        $this
            -&gt;addAscendingNameSort($sortConfigBuilder)
            -&gt;addDescendingNameSort($sortConfigBuilder)
            -&gt;addAscendingPriceSort($sortConfigBuilder)
            -&gt;addDescendingPriceSort($sortConfigBuilder);
    }

    /**
     * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder
     *
     * @return $this
	 */
	protected function addNameSort(SortConfigBuilderInterface $sortConfigBuilder)
	{
		$nameSortConfig = (new SortConfigTransfer())
			-&gt;setName('name')
			-&gt;setParameterName('name')
			-&gt;setFieldName(PageIndexMap::STRING_SORT);

		$sortConfigBuilder-&gt;addSort($nameSortConfig);

		return $this;
	}

	/**
	 * @param \Spryker\Client\Search\Dependency\Plugin\SortConfigBuilderInterface $sortConfigBuilder
	 *
	 * @return $this
	 */
	protected function addPriceSort(SortConfigBuilderInterface $sortConfigBuilder)
	{
		$priceSortConfig = (new SortConfigTransfer())
			-&gt;setName('price')
			-&gt;setParameterName('price')
			-&gt;setFieldName(PageIndexMap::INTEGER_SORT);

		$sortConfigBuilder-&gt;addSort($priceSortConfig);

		return $this;
	}

// ...</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>Just like at the facet filters, here you could create and add as many <var>SortConfigTransfers</var> as you need. The transfer’s options are the following:</p>
        <ul>
            <li><strong>setName()</strong>: <i>Required</i> field, the name of the target data to sort by.</li>
            <li><strong>setParameterName()</strong>: <i>Required</i> field, the name that will be used in the request when the sort is used.</li>
            <li><strong>setFieldName()</strong>: <i>Required</i> field, the name of the field of the page mapping type where the target data is stored.</li>
        </ul>
        <p class="note"><strong>Sort by relevance </strong>
            <br />Elasticsearch is by default sorting by relevance. The cost of each document is calculated based on your search query.</p>
        <p>The last method we’ll need to implement in the <var>CatalogSearchConfigBuilder</var> is the <var>buildPaginationConfig()</var> to configure the pagination of the results.</p><pre><code class="language-PHP line-numbers">&lt;?php

namespace Pyz\Client\Catalog\Plugin\Config;

use Generated\Shared\Transfer\PaginationConfigTransfer;
use Spryker\Client\Search\Dependency\Plugin\FacetConfigBuilderInterface;
// ...

    const DEFAULT_ITEMS_PER_PAGE = 6;
    const VALID_ITEMS_PER_PAGE_OPTIONS = [6, 18, 36];

    /**
     * @param \Spryker\Client\Search\Dependency\Plugin\PaginationConfigBuilderInterface $paginationConfigBuilder
     *
     * @return void
     */
    public function buildPaginationConfig(PaginationConfigBuilderInterface $paginationConfigBuilder)
    {
        $paginationConfigTransfer = (new PaginationConfigTransfer())
            -&gt;setParameterName('page')
            -&gt;setItemsPerPageParameterName('ipp')
            -&gt;setDefaultItemsPerPage(self::DEFAULT_ITEMS_PER_PAGE)
            -&gt;setValidItemsPerPageOptions(self::VALID_ITEMS_PER_PAGE_OPTIONS);

        $paginationConfigBuilder-&gt;setPagination($paginationConfigTransfer);
    }

// ...</code></pre>
        <p>This time we need to create only one instance from <var>PaginationConfigTransfer</var> and set it in the <var>$paginationConfigBuilder</var>. The transfer’s options are the following:</p>
        <ul>
            <li><strong>setParameterName()</strong>: <i>Required</i> field, the name that will be used in the request for the current page.</li>
            <li><strong>setItemsPerPageParameterName()</strong>: <i>Optional</i> field, if defined this name will be used in the request for changing the items per page parameter.</li>
            <li><strong>setDefaultItemsPerPage()</strong>: <i>Optional</i> field, the value of the default items per page.</li>
            <li><strong>setValidItemsPerPageOptions()</strong>: <var>Optional</var> field, an array of valid items per page options.</li>
        </ul>
        <p>After fully implementing the config builder plugin, we’ll need to provide it on project level in the <var>SearchDependencyProvider</var>.</p><pre><code class="language-PHP line-numbers">&lt;?php

namespace Pyz\Client\Search;

use Pyz\Client\Catalog\Plugin\Config\CatalogSearchConfigBuilder;
use Spryker\Client\Kernel\Container;
use Spryker\Client\Search\SearchDependencyProvider as SprykerSearchDependencyProvider;

class SearchDependencyProvider extends SprykerSearchDependencyProvider
{

    /**
     * @param \Spryker\Client\Kernel\Container $container
     *
     * @return \Spryker\Client\Search\Dependency\Plugin\SearchConfigBuilderInterface
     */
    protected function createSearchConfigBuilderPlugin(Container $container)
    {
        return new CatalogSearchConfigBuilder();
    }

}</code></pre>
        <p>After you provided the instance of your search configuration builder the <i>expander</i> and <i>result formatter</i> plugins will start to generate data for you the next time you’ll run a search query. This tutorial doesn’t covers how to display the filters, but you can find examples for that in our Demoshop if you need some.</p>
    </body>
</html>