<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="Spryker.DemoShop">
    <head><title>Development - Collector | Spryker</title>
        <meta name="description" content="The Collector module provides mechanisms to manage data consumed by front-end application. This article covers steps required to populate the data stores." />
    </head>
    <body>
        <h1>Development - Collector <img src="../../../Resources/Images/shoptype/Demoshop.png" /></h1>
        <p>The Collector module provides mechanisms to manage data consumed by front-end application.

To populate the data stores, 4 steps are required:

</p>
        <ul class="obullet">
            <li class="bullet_list">
                <MadCap:xref href="#Touch">Touch
</MadCap:xref><![CDATA[
]]></li>
            <li class="bullet_list">
                <MadCap:xref href="#Configu">Configure
</MadCap:xref><![CDATA[
]]></li>
            <li class="bullet_list">
                <MadCap:xref href="#Collect">Collect
</MadCap:xref><![CDATA[
]]></li>
            <li class="bullet_list" MadCap:conditions="General.Draft">Export
 - to check we are missing information about export</li>
        </ul>
        <h2><a name="Touch"></a>Touch
</h2>
        <p>In order for anything to be synchronized, first it has to be marked (touched) via the <a href="../touch.htm">Touch mechanism</a>. Each collector uses this mechanism to be able to determine which data should be added, updated or deleted.

</p>
        <p class="info">
            <br>
            </br>Cascading Updates, depending on the type of data changed, can trigger cascade update of multiple resources. <br></br>For example: renaming of a category will result in updating the urls, category nodes, navigation and products.
</p>
        <p>The basic idea is that, any resource which should be exported, has an entry in the <var>spy_touch</var> table. This table is used by collector’s query, to collect items marked for synchronization.

</p>
        <p>See <a href="../touch.htm">Touch</a>  for more information.

</p>
        <h3>Touch Record
</h3>
        <p>CollectorQueries must read information from <var>spy_touch</var> table in order to determine which resources should be collected. Depending on Collector Store Type, the <var>spy_touch_storage</var> or <var>spy_touch_search</var> table records are also needed. These records are used to determine the keys of the resources that are exported to client-side data stores, and this combined information represents the <b>Touch Record</b>.

</p>
        <h4>SQL Touch Record Implementation
</h4>
        <p>To write a collector SQL query, you must include the following 3 columns:

</p>
        <ul>
            <li class="bullet_list">id_touch from the spy_touch table
</li>
            <li class="bullet_list">item_id from the spy_touch table
</li>
            <li class="bullet_list">id either from the spy_touch_storage or the spy_touch_search, depending on the case.
</li>
        </ul>
        <p><b>Storage</b>:

</p><pre><code class="language-PHP line-numbers"> ...
    spy_touch.id_touch AS %s,
    spy_touch.item_id AS %s,
    spy_touch_storage.id_touch_storage AS %s,
 ...
   INNER JOIN spy_touch t ON (tree.id_category_node = t.item_id AND t.item_type = :itemType)
   LEFT JOIN spy_touch_storage ON spy_touch_storage.fk_touch = t.id_touch AND spy_touch_storage.fk_locale = :fk_locale</code></pre>
        <p><b>Search</b>:
</p><pre><code class="language-PHP line-numbers"> ...
    spy_touch.id_touch AS %s,
    spy_touch.item_id AS %s,
    spy_touch_search.id_touch_search AS %s,
 ...
   INNER JOIN spy_touch t ON (tree.id_category_node = t.item_id AND t.item_type = :itemType)
   LEFT JOIN spy_touch_search ON spy_touch_search.fk_touch = t.id_touch AND spy_touch_search.fk_locale = :fk_locale</code></pre>
        <p><var>
:itemType</var> is the collectorType and <var>:fk_locale</var> is <var>idLocale</var> from <var>spy_locale</var> table. Each placeholder (%s) for the Touch columns will be replaced by values that are defined in the <var>CollectorConfig</var>. Check <var>prepareCollectorScope()</var> methods for implementation details.

</p>
        <h4>Propel Touch Record Implementation
</h4>
        <p>For Propel type collector query those steps are not required, as the information about Touch Record is already integrated.
</p>
        <h2><a name="Configu"></a>
Configure
</h2>
        <p>The collectors register through plugins. When adding a new collector, you must create a dedicated plugin for it in the <var>Communication </var>layer, under the <var>Plugin/</var> folder. The plugin for the new collector must extend <var>AbstractCollectorPlugin</var> class and must implement the <var>run()</var> method which calls the corresponding <var>CollectorFacade</var> that calls the associated collector.

</p><pre><code class="language-PHP line-numbers">&lt;?php
/**
 * @param \Orm\Zed\Touch\Persistence\SpyTouchQuery $baseQuery
 * @param \Generated\Shared\Transfer\LocaleTransfer $locale
 * @param \Spryker\Zed\Collector\Business\Model\BatchResultInterface $result
 * @param \Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface $dataWriter
 * @param \Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface $touchUpdater
 * @param \Symfony\Component\Console\Output\OutputInterface $output
 *
 * @return void
 */
abstract public function run(
    SpyTouchQuery $baseQuery,
    LocaleTransfer $locale,
    BatchResultInterface $result,
    WriterInterface $dataWriter,
    TouchUpdaterInterface $touchUpdater,
    OutputInterface $output
);
?&gt;</code></pre>
        <p><b>Example</b>: <var>NavigationCollectorStoragePlugin</var>.</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Collector\Communication\Plugin;

use Generated\Shared\Transfer\LocaleTransfer;
use Orm\Zed\Touch\Persistence\SpyTouchQuery;
use Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface;
use Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface;
use Spryker\Zed\Collector\Business\Model\BatchResultInterface;
use Spryker\Zed\Collector\Communication\Plugin\AbstractCollectorPlugin;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * @method \Pyz\Zed\Collector\Communication\CollectorCommunicationFactory getFactory()
 * @method \Pyz\Zed\Collector\Business\CollectorFacade getFacade()
 */
class NavigationCollectorStoragePlugin extends AbstractCollectorPlugin
{

    /**
     * @param \Orm\Zed\Touch\Persistence\SpyTouchQuery $baseQuery
     * @param \Generated\Shared\Transfer\LocaleTransfer $locale
     * @param \Spryker\Zed\Collector\Business\Model\BatchResultInterface $result
     * @param \Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface $dataWriter
     * @param \Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface $touchUpdater
     * @param \Symfony\Component\Console\Output\OutputInterface $output
     *
     * @return void
     */
    public function run(
        SpyTouchQuery $baseQuery,
        LocaleTransfer $locale,
        BatchResultInterface $result,
        WriterInterface $dataWriter,
        TouchUpdaterInterface $touchUpdater,
        OutputInterface $output
    ) {
        $this-&gt;getFacade()
            -&gt;runStorageNavigationCollector($baseQuery, $locale, $result, $dataWriter, $touchUpdater, $output);
    }

}
?&gt;</code></pre>
        <p>
Of course, for each collector a dedicated method must be defined in the CollectorFacade, that makes the connection between the collector plugin and the collector.

</p><pre><code class="language-PHP line-numbers">&lt;?php
/**
 * @param \Orm\Zed\Touch\Persistence\SpyTouchQuery $baseQuery
 * @param \Generated\Shared\Transfer\LocaleTransfer $locale
 * @param \Spryker\Zed\Collector\Business\Model\BatchResultInterface $result
 * @param \Spryker\Zed\Collector\Business\Exporter\Writer\WriterInterface $dataWriter
 * @param \Spryker\Zed\Collector\Business\Exporter\Writer\TouchUpdaterInterface $touchUpdater
 *
 * @return void
 */
public function runStorageNavigationCollector(
    SpyTouchQuery $baseQuery,
    LocaleTransfer $locale,
    BatchResultInterface $result,
    WriterInterface $dataWriter,
    TouchUpdaterInterface $touchUpdater,
    OutputInterface $output
) {
    $this-&gt;getFactory()
        -&gt;createStorageNavigationCollector()
        -&gt;run($baseQuery, $locale, $result, $dataWriter, $touchUpdater, $output);
}
?&gt;</code></pre>
        <p>The collectors are registered in the application through their corresponding plugins in the <var>CollectorDependencyProvider </var>class.
</p>
        <p>
the collectors that gather data for search type store are registered under <var>SEARCH_PLUGINS</var></p>
        <p>the collectors that gather data for the storage type store are registered under <var>STORAGE_PLUGINS</var><![CDATA[
]]></p><pre><code class="language-PHP line-numbers">&lt;?php
$container[static::SEARCH_PLUGINS] = function (Container $container) {
    return [
        'product_abstract' =&gt; new ProductCollectorSearchPlugin(),
    ];
};

$container[static::STORAGE_PLUGINS] = function (Container $container) {
    return [
        'product_abstract' =&gt; new ProductCollectorStoragePlugin(),
        'categorynode' =&gt; new CategoryNodeCollectorStoragePlugin(),
        'navigation' =&gt; new NavigationCollectorStoragePlugin(),
        'translation' =&gt; new TranslationCollectorStoragePlugin(),
        'page' =&gt; new PageCollectorStoragePlugin(),
        'block' =&gt; new BlockCollectorStoragePlugin(),
        'redirect' =&gt; new RedirectCollectorStoragePlugin(),
        'url' =&gt; new UrlCollectorStoragePlugin(),
    ];
};
?&gt;</code></pre>
        <h2><a name="Collect"></a>Collect
</h2>
        <p>Data collection is done in 2 steps:

</p>
        <p>Querying/fetching data from the SQL database (Persistence layer)
</p>
        <p>Aggregating/processing data (Business layer)
</p>
        <h3>Query
</h3>
        <p>To fetch data from the database, you can either use a <var>Propel </var>or <var>PDO </var>type query, under the Persistence layer.

</p>
        <ul>
            <li class="bullet_list"><var>AbstractPdoCollectorQuery</var> - uses native <var>SQL
</var></li>
            <li class="bullet_list"><var>AbstractPropelCollectorQuery</var> - uses <var>Propel Query
</var></li>
        </ul>
        <h4>AbstractPdoCollectorQuery
</h4>
        <p><var>AbstractCollectorQuery</var> contains one abstract method <var>prepareQuery()</var>.

</p><pre><code class="language-PHP line-numbers">&lt;?php
/**
 * @return void
 */
abstract protected function prepareQuery();
?&gt;</code></pre>
        <p>You can set your own SQL query with <var>sql()</var> method of <var>CriteriaBuilder</var> interface.
</p><pre><code class="language-PHP line-numbers">&lt;?php
/**
 * @param string $sqlTemplate
 *
 * @return $this
 */
public function sql($sqlTemplate);
?&gt;</code></pre>
        <p>Example of the <var>NavigationCollector</var> query, that uses native <var>PostgreSQL</var> to retrieve hierarchical navigation data.
</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Example of the <var>NavigationCollector</var> query, that uses native <var>PostgreSQL</var> to retrieve hierarchical navigation data.</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Collector\Persistence\Storage\Pdo\PostgreSql;

use Spryker\Zed\Collector\Persistence\Exporter\AbstractPdoCollectorQuery;

class NavigationCollectorQuery extends AbstractPdoCollectorQuery
{

    /**
     * @return void
     */
    protected function prepareQuery()
    {
        $sql = '
WITH RECURSIVE
    tree AS
  (
    SELECT
      n.id_category_node,
      n.fk_parent_category_node,
      n.fk_category,
      n.node_order
    FROM spy_category_node n
      INNER JOIN spy_category c ON c.id_category = n.fk_category AND c.is_active = TRUE AND c.is_in_menu = TRUE
      INNER JOIN spy_touch t ON (
        n.id_category_node = t.item_id
        AND t.item_event = :spy_touch_item_event
        AND t.touched &gt;= :spy_touch_touched
        AND t.item_type = :spy_touch_item_type
      )
    WHERE n.is_root = TRUE

    UNION

    SELECT
      n.id_category_node,
      n.fk_parent_category_node,
      n.fk_category,
      n.node_order
    FROM tree
      INNER JOIN spy_category_node n ON n.fk_parent_category_node = tree.id_category_node
      INNER JOIN spy_category c ON c.id_category = n.fk_category AND c.is_active = TRUE AND c.is_in_menu = TRUE
  )
SELECT
  t.id_touch AS %s,
  t.item_id AS %s,
  spy_touch_storage.id_touch_storage AS %s,
  tree.*,
  u.url,
  ca.name,
  ca.meta_title,
  ca.meta_description,
  ca.meta_keywords,
  ca.category_image_name
FROM tree
  INNER JOIN spy_url u ON (u.fk_resource_categorynode = tree.id_category_node AND u.fk_locale = :fk_locale_1)
  INNER JOIN spy_category_attribute ca ON (ca.fk_category = tree.fk_category AND ca.fk_locale = :fk_locale_2)
  INNER JOIN spy_touch t ON (tree.id_category_node = t.item_id AND t.item_type = :itemType)
  LEFT JOIN spy_touch_storage ON spy_touch_storage.fk_touch = t.id_touch AND spy_touch_storage.fk_locale = :fk_locale_3
';
        $this-&gt;criteriaBuilder
            -&gt;sql($sql)
            -&gt;setOrderBy([
                'tree.fk_parent_category_node' =&gt; 'ASC',
                'tree.node_order' =&gt; 'DESC',
            ])
            -&gt;setParameter('itemType', 'categorynode')
            -&gt;setParameter('fk_locale_1', $this-&gt;locale-&gt;getIdLocale())
            -&gt;setParameter('fk_locale_2', $this-&gt;locale-&gt;getIdLocale())
            -&gt;setParameter('fk_locale_3', $this-&gt;locale-&gt;getIdLocale());
    }

}

?&gt;</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h4>CriteriaBuilder
</h4>
        <p>The collector will use conditions generated by <var>CriteriaBuilder </var>to create data set for synchronization.

</p>
        <p>CriteriaBuilder provides an interface that that makes sure all the parameters and their values are properly bind, or if the order and limit a properly setup, and if they are in the right place in SQL query.

</p>
        <h4>AbstractPropelCollectorQuery
</h4>
        <p>Implementation of <var>AbstractCollectorQuery</var> is fairly simple, as it has only one abstract method <var>prepareQuery()</var>.
</p><pre><code class="language-PHP line-numbers">&lt;?php
/**
 * @return void
 */
abstract protected function prepareQuery();
?&gt;
</code></pre>
        <p>You define your criteria with <var>touchQuery</var> interface, using <var>Propel Query</var>.

</p>
        <p>Example of <var>BlockCollector</var> query, which uses <var>Propel Query</var> to retrieve CMS blocks data.
</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Example of a <var>BlockCollector</var> query, using a <var>Propel Query</var> to retrieve CMS blocks data.
</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Collector\Persistence\Storage\Propel;

use Orm\Zed\Cms\Persistence\Map\SpyCmsBlockTableMap;
use Orm\Zed\Cms\Persistence\Map\SpyCmsGlossaryKeyMappingTableMap;
use Orm\Zed\Cms\Persistence\Map\SpyCmsPageTableMap;
use Orm\Zed\Cms\Persistence\Map\SpyCmsTemplateTableMap;
use Orm\Zed\Glossary\Persistence\Map\SpyGlossaryKeyTableMap;
use Orm\Zed\Touch\Persistence\Map\SpyTouchTableMap;
use Orm\Zed\Url\Persistence\Map\SpyUrlTableMap;
use Propel\Runtime\ActiveQuery\Criteria;
use Spryker\Zed\Collector\Persistence\Exporter\AbstractPropelCollectorQuery;

class BlockCollectorQuery extends AbstractPropelCollectorQuery
{

    /**
     * @return void
     */
    protected function prepareQuery()
    {
        $this-&gt;touchQuery-&gt;addJoin(
            SpyTouchTableMap::COL_ITEM_ID,
            SpyCmsBlockTableMap::COL_ID_CMS_BLOCK,
            Criteria::INNER_JOIN
        );
        $this-&gt;touchQuery-&gt;addJoin(
            SpyCmsBlockTableMap::COL_FK_PAGE,
            SpyCmsPageTableMap::COL_ID_CMS_PAGE,
            Criteria::INNER_JOIN
        );
        $this-&gt;touchQuery-&gt;addJoin(
            SpyCmsPageTableMap::COL_ID_CMS_PAGE,
            SpyCmsGlossaryKeyMappingTableMap::COL_FK_PAGE,
            Criteria::INNER_JOIN
        );
        $this-&gt;touchQuery-&gt;addJoin(
            SpyCmsPageTableMap::COL_FK_TEMPLATE,
            SpyCmsTemplateTableMap::COL_ID_CMS_TEMPLATE,
            Criteria::INNER_JOIN
        );
        $this-&gt;touchQuery-&gt;addJoin(
            SpyCmsGlossaryKeyMappingTableMap::COL_FK_GLOSSARY_KEY,
            SpyGlossaryKeyTableMap::COL_ID_GLOSSARY_KEY,
            Criteria::INNER_JOIN
        );

        $this-&gt;touchQuery-&gt;addAnd(
            SpyUrlTableMap::COL_FK_LOCALE,
            $this-&gt;getLocale()-&gt;getIdLocale(),
            Criteria::EQUAL
        );

        $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_ID_CMS_BLOCK, 'block_id');
        $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_NAME, 'block_name');
        $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_TYPE, 'block_type');
        $this-&gt;touchQuery-&gt;withColumn(SpyCmsBlockTableMap::COL_VALUE, 'block_value');
        $this-&gt;touchQuery-&gt;withColumn(SpyCmsGlossaryKeyMappingTableMap::COL_PLACEHOLDER, 'placeholder');
        $this-&gt;touchQuery-&gt;withColumn(SpyCmsTemplateTableMap::COL_TEMPLATE_PATH, 'template_path');
        $this-&gt;touchQuery-&gt;withColumn(SpyCmsPageTableMap::COL_IS_ACTIVE, 'isActive');
        $this-&gt;touchQuery-&gt;withColumn(SpyGlossaryKeyTableMap::COL_KEY, 'translation_key');
    }

}

?&gt;</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h3>Process</h3>
        <p>There are four collector types, grouped by store and query type they use.</p>
        <h4>Storage Collectors</h4>
        <ul>
            <li class="bullet_list"><var>AbstractStoragePdoCollector</var> - uses <var>PDO </var>type query</li>
            <li class="bullet_list"><var>AbstractStoragePropelCollector</var> - uses <var>Propel </var>type query</li>
        </ul>
        <p>The entities processed by those collectors will be synchronized with Storage type data store.</p>
        <h4>Search Collectors</h4>
        <ul>
            <li class="bullet_list"><var>AbstractSearchPdoCollector</var> - uses <var>PDO </var>type query</li>
            <li class="bullet_list"><var>AbstractSearchPropelCollector</var> - uses <var>Propel </var>type query</li>
        </ul>
        <p>The entities processed by those collectors will be synchronized with Search type data store.</p>
        <p>After fetching data from the <var>Persistence </var>layer, and processing in Buissiness layer, it is saved under the <var>TouchKey </var>in the data store. A <var>TouchKey </var>is any unique string that can be used to identify resources in the stores.</p>
        <p>There are two abstract methods, which every collector has to implement.</p><pre><code class="language-PHP line-numbers">&lt;?php
/**
 * @param string $touchKey
 * @param array $collectItemData
 *
 * @return array
 */
abstract protected function collectItem($touchKey, array $collectItemData);

/**
 * @return string
 */
abstract protected function collectResourceType();
?&gt;</code></pre>
        <p>The string returned by <var>collectResourceType()</var> is used to generate the <var>TouchKey</var>.</p>
        <p>The <var>collectItem()</var> method decides which data is saved under the <var>TouchKey </var>in the store.</p>
        <p>Example of a <var>RedirectCollector</var> class, which uses Storage type data store.</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Collector\Business\Storage;

use Spryker\Zed\Collector\Business\Collector\Storage\AbstractStoragePropelCollector;
use Spryker\Zed\Url\UrlConfig;

class RedirectCollector extends AbstractStoragePropelCollector
{

    /**
     * @return string
     */
    protected function collectResourceType()
    {
        return 'redirect';
    }

    /**
     * @param string $touchKey
     * @param array $collectItemData
     *
     * @return array
     */
    protected function collectItem($touchKey, array $collectItemData)
    {
        return [
            'from_url' =&gt; $collectItemData['from_url'],
            'to_url' =&gt; $collectItemData['to_url'],
            'status' =&gt; $collectItemData['status'],
            'id' =&gt; $collectItemData['id'],
        ];
    }

}
?&gt;</code></pre>
        <p>The output of this collector will produce a <var>redirect </var>type entity, stored under <var>kv:de.de_de.resource.redirect.1 </var>key, with the following content:</p><pre><code class="language-PHP line-numbers">{
    "from_url": "/imp",
    "to_url": "/impressum",
    "status": 303,
    "id": 1
}</code></pre>
        <p>The content of <var>$collectItemData</var> array represents one row from the result set, generated by the collector’s query in Persistence layer.</p>
        <p><![CDATA[
]]><MadCap:relatedTopics><MadCap:relatedTopic src="collector.htm" /><MadCap:relatedTopic src="collector_development.htm" /><MadCap:relatedTopic src="collector-running.htm" /><MadCap:relatedTopic src="collector-sched-collector-jobs.htm" /><MadCap:relatedTopic src="collector-types.htm" /></MadCap:relatedTopics></p>
    </body>
</html>