<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:conditions="Spryker.B2B,Spryker.B2C">
    <head><title>Tutorial - Pages and Widgets | Spryker</title>
        <link href="../../Resources/TableStyles/PatternedRows2.css" rel="stylesheet" MadCap:stylesheetType="table" />
        <meta name="description" content="This tutorial provides information on what the Pages and Widgets in Spryker Commerce OS are and how they can be implemented and rendered." />
    </head>
    <body>
        <h1>Tutorial - Pages and Widgets <img src="../../Resources/Images/shoptype/B2B_Shop.png" /> <img src="../../Resources/Images/shoptype/B2C_Shop.png" /><img src="../../Resources/Images/shoptype/MasterSuite.png" /> <img src="../../Resources/Images/shoptype/Demoshop.png" /></h1>
        <p>Th<MadCap:annotation MadCap:createDate="2019-02-06T19:18:27.2766013+02:00" MadCap:creator="oksana.karasyova" MadCap:initials="OK" MadCap:comment="need to clarify whether this info is Legacy Demoshop - compatible. If not - remove an icon.\r\n" MadCap:editor="oksana.karasyova" MadCap:editDate="2019-02-06T19:19:00.7811389+02:00">is tutoria</MadCap:annotation>l provides information on what the <a href="#Pages">Pages</a> and <a href="#Widgets">Widgets</a> are and what real-life examples can help you to understand the concept more, how does the Pages module look like, how the Pages module can be extended and what procedure you need to follow in order to implement the Widget. </p>
        <h2>General Information </h2>
        <h3><a name="Pages"></a>Pages</h3>
        <p><b>Pages</b> are the main concept of modular front-end (Yves) which splits code into modules. A <i>Page module</i> represents a set of pages displayed under some or similar URLs that logically belong together.</p>
        <div class="example">
            <p class="example">As an example, we consider <b>Product Detail Page</b> as one <i>Page module</i> which is responsible for displaying products and their basic information.</p>
            <p>
                <img src="../../Resources/Images/Tutorial - Pages and Widgets/pdp-page.png" />
            </p>
        </div>
        <p class="example">Another <i>Page module</i> example would be any customer related pages, like <b>Login</b>, <b>Register</b>, <b>Profile</b>, <b>Addresses</b>. These are several different pages. Each page is responsible for something specific from the customer domain, so it's natural to group them under the same module.</p>
        <p>We group pages under a Page module when they are related to the same domain.</p>
        <h3><a name="Widgets"></a>Widgets</h3>
        <p>Meanwhile, <i>Page modules</i> implement only feature basics, while <b>Widgets</b> provide optional extensions for them.</p>
        <div class="example">
            <p class="example"><b>Product Detail Page</b> shows basic product information, like the <i>name</i>, <i>description</i> and <i>attributes</i> of the product. But there are lots of optional features that can appear on the same page. The most commonly used examples are <i>product image</i>, <i>price</i>, <i>availability</i>, <i>options</i>, <i>groups</i>, <i>rating</i>, <i>relations</i>, an much more.
</p>
            <p>
                <img src="../../Resources/Images/Tutorial - Pages and Widgets/pdp-ratings.png" />
            </p>
        </div>
        <p>The <i>Pages</i> and <i>Widgets</i> concept offers a solution to tailor projects to their custom needs.</p>
        <p>When you get the general understanding of the <i>Pages</i>/<i>Widgets</i> concept, its time to investigate how the Pages module looks like, why and how the module can be extended.</p>
        <h3>Page Module Appearance and Pages Extension</h3>
        <p>A <b>Page</b> module typically contains a <var>ControllerProvider</var> plugin for routing (see <a href="https://documentation.spryker.com/yves/yves-url-routing.htm">URL Routing</a>) and some Controllers with their twig templates (see <a href="https://documentation.spryker.com/yves/controllers-actions.htm">Controllers and Actions</a>). The implementation scope of a <b>Page</b> module should be decided individually, depending on its need of re-usability. </p>
        <p class="info">The more generic a <b>Page</b> module is the more it can be reused, but also it needs more extension points this way.
		</p>
        <p>As more features you need to have on in your <b>Page</b> module, as much you need to extend it.</p>
        <p>To extend a Page with an additional functionality you use <b>Widgets</b>. When you extend the front-end by rendering a template fragment in a template of a controller action, you need to specify the exact place of each extension point on template level.</p>
        <p>
            <img src="../../Resources/Images/product-details-page-schema-temlate.png" />
        </p>
        <div class="tip">
            <p class="tip">Before you start using the widget system, make sure to register the <var>\SprykerShop\Yves\ShopApplication\Plugin\Provider\WidgetTagServiceProvider</var> in your <var>YvesBoostrap</var>.</p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\ShopApplication;
 
use SprykerShop\Yves\ShopApplication\Plugin\Provider\WidgetTagServiceProvider;
use SprykerShop\Yves\ShopApplication\YvesBootstrap as SprykerYvesBootstrap;
 
class YvesBootstrap extends SprykerYvesBootstrap
{
	/**
	 * @return void
	 */
	protected function registerServiceProviders()
	{
		$this-&gt;application-&gt;register(new WidgetTagServiceProvider());
	}
}</code></pre>
        </div>
        <h2><a name="How_to_implement_a_Widget?"></a>How to Implement a Widget?</h2>
        <p>Each widget implementation is supposed to be designed as components: considering reusability and being able to render them on different Pages.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 1 - Implement the Widget class</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>To implement a widget class follow the detailed example below.</p><pre><code class="language-PHP line-numbers">&lt;?php
  
namespace Pyz\Yves\FooModule\Widget;
  
use Spryker\Yves\Kernel\Widget\AbstractWidget;
  
class FooBarWidget extends AbstractWidget
{
	public function __construct($arg1, $arg2, ...)
	{
		// The constructor arguments are the input to render/create a widget in twig templates.
		// The constructor initializes the widget parameters that will be available inside the template to be rendered.
		// The widget parameters are publicly available on a widget instance by its ArrayAccess interface.
		$this-&gt;addParameter('param1', ...)
			-&gt;addParameter('param2', ...);
	}
  
	public function getName(): string
	{
		// By convention the name of the widgets are equal with the name of the widget class to be able to find it easily from twig templates.
		// The widget names must be unique as they are registered globally.
		return 'FooBarWidget';
	}
      
	public function getTemplate(): string
	{
		// The template of the widget to be rendered by default.
		return '@FooModule/views/foo-bar-widget/foo-bar-widget.twig';
	}
}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 2 - Implement the Widget template</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Create the template file that was added in your <var>Widget's getTemplate()</var> method previously.</p>
                <p>In the template of the widget, the parameters are accessible through the <var>_widget</var> twig variable. This way in twig template it's easy to determine where is a parameter coming from.</p>
                <p class="example">When you see <var>_widget.foo</var>, it means that the foo parameter is coming from the widget directly.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 3 - Activate your Widget</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>You can activate Widgets by adding them to <var>\Pyz\Yves\ShopApplication\ShopApplicationDependencyProvider::getGlobalWidgets()</var> method. Widgets are instantiated in the background when they are called in twig templates. To activate a widget just use their <b>FQCNs</b> (Fully Qualified Class Names).</p>
                <p class="info">A widget with a given set of parameters, called multiple times, in the same <code>http</code> request is instantiated only once and cached in the memory for performance reasons. This also means that when there is a widget which has a bit heavier initialization logic, it will be executed only once even when used several times in twig templates. When the same widget is called with different params it will still be a new instance and run its initialization separately.</p>
                <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\ShopApplication;
 
use Pyz\Yves\FooModule\Widget\FooBarWidget;
use SprykerShop\Yves\ShopApplication\ShopApplicationDependencyProvider as SprykerShopApplicationDependencyProvider;
 
class ShopApplicationDependencyProvider extends SprykerShopApplicationDependencyProvider
{
	/**
	 * @return string[]
	 */
	protected function getGlobalWidgets(): array
	{
		return [
			FooBarWidget::class,
		];
	}
}</code></pre>
                </p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 4 - Render the Widget</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Widgets are placed and rendered in twig templates. The following examples show several cases how to use them.</p>
                <p><b>Simple widget rendering with input parameters:</b>
                </p><pre><code class="language-xml">{% widget 'FooWidget' args [param1, param2] only %}
{% endwidget %}</code></pre>
                <p><b>Widget rendering with different templates:</b>
                </p><pre><code class="language-xml line-numbers">{% widget 'FooWidget' use view('view1') only %}
{% endwidget %}
 
{% widget 'FooWidget' use view('view2') only %}
{% endwidget %}</code></pre>
                <p><b>Widget rendering with additional HTML:</b>
                </p><pre><code class="language-xml line-numbers">{% set color = 'red' %}
 
{% if widgetExists('FooWidgetPlugin') %}
	&lt;div style="border:1px solid {{ color }}"&gt;
		{{ widget('FooWidgetPlugin', param1, param2) }}
	&lt;/div&gt;
{% endif %}				</code></pre>
                <p><b>Widget rendering with additional HTML and context variables:</b>
                </p><pre><code class="language-xml line-numbers">{% widget 'FooWidget' args [param1, param2] with {color: 'red'} only %}
	{% block body %}
		&lt;div style="border:1px solid {{ color }}"&gt;
			{{ parent() }}
		&lt;/div&gt;
	{% endblock %}
{% endwidget %}</code></pre>
                <p><b>Widget rendering with fallback when it doesn't exist or not activated:</b>
                </p><pre><code class="language-xml line-numbers">{% widget 'FooWidget' args [param1, param2] only %}
{% nowidget %}
	display something else here...
{% endwidget %}						</code></pre>
                <p><b>Render widget into a variable:</b>
                </p><pre><code class="language-xml">{% set fooWidget = findWidget('FooWidget', [param1, param2]) %}
{% set foo = fooWidget.foo|default %}</code></pre>
                <p><b>Subsequently, render widgets as a fallback when another widget doesn't exist:</b>
                </p><pre><code class="language-xml line-numbers">{% widget 'FooWidget' only %}
{% elsewidget 'BarWidget' only %}
{% nowidget %}
	display something else here...
{% endwidget %}</code></pre>
                <h3>widget Twig Tag Reference</h3><pre><code class="language-xml line-numbers">{% widget WIDGET_EXPRESSION args WIDGET_ARGUMENTS use TWIG_TEMPLATE_PATH with TWIG_PARAMETERS only %}
	{% block WIDGET_BLOCK_N %}
		{{ parent() }}
	{% endblock %}
{% elsewidget ... %}
{% nowidget %}
	WIDGET_FALLBACK
{% endwidget %}</code></pre>
                <div class="table-wrap">
                    <table style="mc-table-style: url('../../Resources/TableStyles/PatternedRows2.css');border-top-left-radius: 4px;border-top-right-radius: 4px;border-bottom-right-radius: 4px;border-bottom-left-radius: 4px;border-left-style: solid;border-left-width: 1px;border-left-color: #e7ebef;border-right-style: solid;border-right-width: 1px;border-right-color: #e7ebef;border-top-style: solid;border-top-width: 1px;border-top-color: #e7ebef;border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: #e7ebef;margin-left: 0;margin-right: auto;width: 100%;" class="TableStyle-PatternedRows2" cellspacing="0">
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <thead>
                            <tr class="TableStyle-PatternedRows2-Head-Header1">
                                <th class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Tag</th>
                                <th class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Description</th>
                                <th class="TableStyle-PatternedRows2-HeadD-Regular-Header1">Additional Comments</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>{% widget ... %}...{% endwidget %}</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Required twig tag to render a widget.
                            </td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">A widget is rendered only when it can be found in the local or global widget registry.
                            </td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>WIDGET_EXPRESSION</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Can be a string that represents the name of the widget or an instance of a widget.
					</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows">This argument is required.</td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>args WIDGET_ARGUMENTS</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Array of arguments that the widget is initialized with (by <var>constructor() of new widgets or by initialize()</var> method of old widget plugins). This parameter is only available when <var>ЮWIDGET_EXPRESSION</var> was not an instance of a widget.
					</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">This parameter is optional, depending if the widget object to be initialized requires any arguments or not.</td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>use TWIG_TEMPLATE_PATH</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Render the widget with a different template then defined by the widget. <var>TWIG_TEMPLATE_PATH</var> is a string that represents a valid path for a twig template that can be loaded.</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows">This parameter is optional.</td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>with TWIG_PARAMETERS</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Pass an associative array of variables for the scope of the rendered widget twig blocks. 
							</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">This parameter is optional.</td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>{% block WIDGET_BLOCK_N %}{% endblock %}</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Twig blocks to overwrite/customize blocks of the twig template to be rendered. <var>{{ parent() }}</var> can be used to render the original content of a block. </td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows">This tag is optional.</td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>only</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Optional argument to reduce the context of the template to be rendered to only the provided <var>TWIG_PARAMETERS</var>. </td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">By convention, in Spryker core we always provide this argument to prevent mixing template scopes.</td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>{% elsewidget ... %}</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Optional twig tag to render a widget when the previous widget(s) were not found. Has the same parameters as the base widget tag including <var>WIDGET_BLOCK_N</var>.                             </td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows">Listing multiple <var>elsewidget</var> tags will render the first widget that is found.
                            </td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyB-Regular-LightRows"><var>{% nowidget %} WIDGET_FALLBACK</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyB-Regular-LightRows">Optional twig tag to render any content <var>(WIDGET_FALLBACK)</var>, when no widget is found by the widget tag.</td>
                                <td class="TableStyle-PatternedRows2-BodyA-Regular-LightRows">N/A
                            </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <h3>findWidget() Twig Function Reference</h3><pre><code class="language-xml">{% set widget = findWidget(WIDGET_NAME, WIDGET_ARGUMENTS) %}
 
{{ widget.WIDGET_PARAMETER_N ?? null }}</code></pre>
                <div class="table-wrap">
                    <table style="mc-table-style: url('../../Resources/TableStyles/PatternedRows2.css');border-top-left-radius: 4px;border-top-right-radius: 4px;border-bottom-right-radius: 4px;border-bottom-left-radius: 4px;border-left-style: solid;border-left-width: 1px;border-left-color: #e7ebef;border-right-style: solid;border-right-width: 1px;border-right-color: #e7ebef;border-top-style: solid;border-top-width: 1px;border-top-color: #e7ebef;border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: #e7ebef;margin-left: 0;margin-right: auto;width: 100%;" class="TableStyle-PatternedRows2" cellspacing="0">
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <thead>
                            <tr class="TableStyle-PatternedRows2-Head-Header1">
                                <th class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Tag</th>
                                <th class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Description</th>
                                <th class="TableStyle-PatternedRows2-HeadD-Regular-Header1">Additional Comments</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>findWidget(WIDGET_NAME)</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Find a widget by name and return it as an object. </td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">When a widget is not found, null will be returned instead. 
                            </td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>WIDGET_ARGUMENTS</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Array of arguments that the widget is initialized with <var>(by constructor()</var> of new widgets or by <var>initialize()</var> method of old widget plugins).</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows">This parameter is optional, depending if the widget object to be initialized requires any arguments or not.
</td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyB-Regular-LightRows"><var>widget.WIDGET_PARAMETER_N ?? null</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyB-Regular-LightRows">Get parameters of the widget through its <var>ArrayAccess</var> interface. </td>
                                <td class="TableStyle-PatternedRows2-BodyA-Regular-LightRows">The <var>??</var> check is required in all cases to prevent errors of non-existing widgets.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h2>Deprecations</h2>
        <p>The Page and Widget concepts were introduced in <var>spryker/kernel: 3.16.0</var> module version and originally Widgets were implemented as Yves plugins. Later, in <b>3.24.0</b> version of the Kernel module the widget plugins were deprecated. They started to be used  in their own domain called <b>Widget</b>. Use the following documentation in case you are on a later Kernel version.</p>
        <h3>Widget Plugins</h3>
        <p><b>Widget Plugins</b> are scoped to a single use case. It's the main difference to Widgets which could be called from different Pages.</p>
        <p>Before you start using the widget plugin system, make sure to register the <var>\SprykerShop\Yves\ShopApplication\Plugin\Provider\WidgetServiceProvider</var> in your <var>YvesBoostrap</var>.</p>
        <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\ShopApplication;
 
use SprykerShop\Yves\ShopApplication\Plugin\Provider\WidgetServiceProvider;
use SprykerShop\Yves\ShopApplication\YvesBootstrap as SprykerYvesBootstrap;
 
class YvesBootstrap extends SprykerYvesBootstrap
{
	/**
	 * @return void
	 */
	protected function registerServiceProviders()
	{
		$this-&gt;application-&gt;register(new WidgetServiceProvider());
	}
}</code></pre>
        </p>
        <h3>How to Implement Widget Plugins?</h3>
        <p>Widgets are implemented on demand of an extension of a template. Follow the steps below to implement a widget.</p>
        <p>
            <img src="../../Resources/Images/MyPage_module.png" style="max-width: 60%;" />
        </p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 1 - Place Widget extensions</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p><a name="step1"></a>In the module you are planning to extend, find the extension point in the twig templates and place the necessary twig widget function(s) (see <a href="#How_to_implement_a_Widget?">How to implement a Widget</a> section).</p>
                <p><var>@MyPage/views/foo/foo-bar.twig</var>
                </p><pre><code class="language-xml">&lt;p&gt;Some MyPage related content.&lt;/p&gt;
 
{{ widget('MyWidgetPlugin', $param1, param2) }}
 
&lt;p&gt;Some other MyPage related content.&lt;/p&gt;</code></pre>
                <p>The following twig functions can be used to hook widgets in any twig template:</p>
                <div class="table-wrap">
                    <table style="mc-table-style: url('../../Resources/TableStyles/PatternedRows2.css');border-top-left-radius: 4px;border-top-right-radius: 4px;border-bottom-right-radius: 4px;border-bottom-left-radius: 4px;border-left-style: solid;border-left-width: 1px;border-left-color: #e7ebef;border-right-style: solid;border-right-width: 1px;border-right-color: #e7ebef;border-top-style: solid;border-top-width: 1px;border-top-color: #e7ebef;border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: #e7ebef;margin-left: 0;margin-right: auto;width: 100%;" class="TableStyle-PatternedRows2" cellspacing="0">
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <col class="TableStyle-PatternedRows2-Column-Regular" />
                        <thead>
                            <tr class="TableStyle-PatternedRows2-Head-Header1">
                                <th class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Function</th>
                                <th class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Description</th>
                                <th class="TableStyle-PatternedRows2-HeadD-Regular-Header1">Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>widget()</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">This is the most commonly used widget function. It renders a widget by name with the given arguments. When the widget is not registered in the <b>current render context</b> of the twig template where the method is called, then there will be no output of it. This makes widgets harmless and optional when they are placed in any template.</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows"><var>{{ widget('WidgetName', ...$arguments) }}</var>
                                </td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>widgetBlock()</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Sometimes a widget defines multiple <a href="https://twig.symfony.com/doc/2.x/tags/block.html">twig blocks</a> that can be rendered separately. By calling this method and providing the appropriate block name you can render only some parts of a widget.

							</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows"><var>{{ widgetBlock('WidgetName', 'blockName', ...$arguments) }}</var>
                                </td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>widgetGlobal()</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Some widgets might need to be rendered on most page or on every page as part of the layout. These widgets are registered in a central place only once and can be rendered in any twig template by calling the <var>widgetGlobal()</var> twig function.</td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows"><var>{{ widgetGlobal('WidgetName', ...$arguments) }}</var>
                                </td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>widgetExists()</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Use this function when you need to check if a widget is registered in the <b>current render context</b> (e.g. will be rendered) and do something in that case. For example, when you need to add a container/separator when the widget is rendered, or when you want to render something else, when a widget is not shown.
                            </td>
                                <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows"><var>{{ widgetExists('WidgetName', ...$arguments) }}</var>
                                </td>
                            </tr>
                            <tr class="TableStyle-PatternedRows2-Body-LightRows">
                                <td class="TableStyle-PatternedRows2-BodyB-Regular-LightRows"><var>widgetGlobalExists()</var>
                                </td>
                                <td class="TableStyle-PatternedRows2-BodyB-Regular-LightRows">Use this function when you need to check if a <b>global</b> widget is registered (e.g. will be rendered) and do something in that case. For example, when you need to add a container/separator when the widget is rendered, or when you want to render something else, when a widget is not shown.
                            </td>
                                <td class="TableStyle-PatternedRows2-BodyA-Regular-LightRows"><var>{{ widgetGlobalExists('WidgetName', ...$arguments) }}</var>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 2 - Create Widget interface and contract</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>In the same module you will create an interface that represents the widget used in the template. This step is important to make <b>Dependency Inversion</b> visible on PHP level in the caller module.</p>
                <p>Create the interface for the widget and define the <var>initialize()</var> method. This method is a must have, it defines the contract (e.g. input) of a widget plugin.</p>
                <p>The inputs of the widget plugins are usually different, that's why the <var>initialize()</var> method has to be defined for each case individually. When calling the <var>widget()</var>, <var>widgetBlock()</var> and <var>widgetGlobal()</var> twig functions, the <var>initialize()</var> method of the widget plugin will be executed internally, thus the system by design makes sure that the required inputs are passed.</p>
                <p>In the following example the <var>initialize()</var> method defines one mandatory and one optional parameter. Also note that the interface defines the <i>NAME</i> constant. It's value is used in <a href="#step1">step 1</a> to identify and render the right widget.</p>
                <p><var>src/Pyz/Yves/MyPage/Dependency/Plugin/MyWidget/MyWidgetPluginInterface.php</var>
                </p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\MyPage\Dependency\Plugin\MyWidget;
 
use Spryker\Yves\Kernel\Dependency\Plugin\WidgetPluginInterface;
 
interface MyWidgetPluginInterface extends WidgetPluginInterface
{
	const NAME = 'MyWidgetPlugin';
 
	/**
	 * @param string $myMandatoryParam
	 * @param int|null $myOptionalParam
	 *
	 * @return void
	 */
	public function initialize(string $myMandatoryParam, int $myOptionalParam = null): void;
}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 3 - Implement the Widget plugin</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>In the target widget module (<b>MyWidget</b> in the examples) now you can implement the widget plugin. Extend  your plugin from <var>\Spryker\Yves\Kernel\Widget\AbstractWidgetPlugin</var> and implement the following methods:</p>
                <ul>
                    <li><var>getName()</var> - returns the name of the widget as it's used in the template. Most cases you can return <var>static::NAME;</var> in the method when the name is defined in the interface.
</li>
                    <li><var>getTemplate()</var> - returns the template file path to renter the widget. </li>
                    <li><var>initialize(</var> - initializes the rendering of the widget template, by processing the input parameters and providing parameters for the template to be rendered. Also, sub-widgets can be registered here.
						<p class="info"> When a widget plugin is called several times with the same parameters by the widget twig functions, this method is executed only once to avoid unnecessary overhead.
					</p></li>
                </ul>
                <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\MyWidget\Plugin\MyPage;
 
use Pyz\Yves\MyPage\Dependency\Plugin\MyWidget\MyWidgetPluginInterface;
use Spryker\Yves\Kernel\Widget\AbstractWidgetPlugin;
 
class MyWidgetPlugin extends AbstractWidgetPlugin implements MyWidgetPluginInterface
{
	/**
	 * @param string $myMandatoryParam
	 * @param int|null $myOptionalParam
	 *
	 * @return void
	 */
	public function initialize(string $myMandatoryParam, int $myOptionalParam = null): void
	{
		$this-&gt;addParameter('myMandatoryParam', $myMandatoryParam)
			-&gt;addParameter('myOptionalParam', $myOptionalParam)
			-&gt;addParameter('myComputedParam', $this-&gt;getMyComputedParam());
	}
 
	/**
	 * @return string
	 */
	public static function getName(): string
	{
		return static::NAME;
	}
 
	/**
	 * @return string
	 */
	public static function getTemplate(): string
	{
		return '@MyWidget/views/my-widget/my-widget.twig';
	}
}</code></pre>
                </p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 4 - Implement Widget template</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Create the template file that was added in your Widget's <var>getTemplate()</var> method previously.</p>
                <p>In the template of the widget the parameters are accessible through the <var>_widget</var> twig variable. This way in twig template it's easy to determine where is a parameter coming from, when you see <var>_widget.foo</var>, it means that the foo parameter is coming from the widget directly.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Step 5 - Activate the Widget</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>There are three ways of activating a widget, depending on their scope where they need to be rendered;</p>
                <ul>
                    <li><a href="#Activate_a_widget_in_a_Controller_action">Activate a widget in a Controller action</a><![CDATA[
]]></li>
                    <li><a href="#activate_a_widget_in_another_widget">Activate a widget in another widget</a>
                    </li>
                    <li>
                        <p><a href="#Activate_a_widget_to_be_available_globally">Activate a widget to be available globally</a>
                        </p>
                    </li>
                </ul>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot>Activate a widget in a Controller action
</MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p><a name="Activate_a_widget_in_a_Controller_action"></a>Most of the times when a Page needs extension we need to extend a template that is rendered by a Controller action. In this case, the action need to return a <var>\Spryker\Yves\Kernel\View\View</var> object. This View object can define the data for the template of the controller to be rendered, the list of active widget plugins and the template to render.</p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\MyPage\Controller;
 
use SprykerShop\Yves\ShopApplication\Controller\AbstractController;
 
/**
 * @method \Pyz\Yves\MyPage\MyPageFactory getFactory()
 */
class FooController extends AbstractController
{
	/**
	 * @return \Spryker\Yves\Kernel\View\View
	 */
	public function barAction()
	{
		return $this-&gt;view(
			$this-&gt;getViewData(),
			$this-&gt;getFactory()-&gt;getMyPageFooBarWidgetPlugins(),
			'@MyPage/views/foo/foo-bar.twig'
		);
	}
 
	/**
	 * @return array
	 */
	protected function getViewData(): array
	{
		return [
			// some key-value array for the template to be rendered
		];
	}
}</code></pre>
                        <div class="info">When a controller action returns a <var>View</var> object, in the rendered twig template by default the data passed from the controller (view data) is accessible through the <var>_view</var> twig variable. This way in twig template it's easy to determine where is a parameter coming from, when you see <var>_view.foo</var>, it means that the foo parameter is coming from the controller directly.
						<p>If you would like to access the parameters directly without the <var>_view</var> variable in twig, set the <code>ShopApplicationConfig::useViewParametersToRenderTwig()</code> module configuration method to return true instead of the default false.</p></div>
                        <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\MyPage;
 
use Spryker\Yves\Kernel\AbstractFactory;
 
class MyPageFactory extends AbstractFactory
{
	/**
	 * @return string[]
	 */
	public function getMyPageFooBarWidgetPlugins(): array
	{
		return $this-&gt;getProvidedDependency(MyPageDependencyProvider::PLUGIN_MY_PAGE_FOO_BAR_WIDGETS);
	}
}										</code></pre>
                        </p>
                        <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\MyPage;
 
use Spryker\Yves\Kernel\AbstractFactory;
 
class MyPageFactory extends AbstractFactory
{
	/**
	 * @return string[]
	 */
	public function getMyPageFooBarWidgetPlugins(): array
	{
		return $this-&gt;getProvidedDependency(MyPageDependencyProvider::PLUGIN_MY_PAGE_FOO_BAR_WIDGETS);
	}
}				
						</code></pre>
                        </p>
                        <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\MyPage;
 
use Pyz\Yves\MyWidget\Plugin\MyPage\MyWidgetPlugin;
use Spryker\Yves\Kernel\AbstractBundleDependencyProvider;
use Spryker\Yves\Kernel\Container;
 
class ProductSetDetailPageDependencyProvider extends AbstractBundleDependencyProvider
{
	const PLUGIN_MY_PAGE_FOO_BAR_WIDGETS = 'PLUGIN_MY_PAGE_FOO_BAR_WIDGETS';
 
	/**
	 * @param \Spryker\Yves\Kernel\Container $container
	 *
	 * @return \Spryker\Yves\Kernel\Container
	 */
	public function provideDependencies(Container $container)
	{
		$container = $this-&gt;addMyPageFooBarWidgetPlugins($container);
 
		return $container;
	}
 
	/**
	 * @param \Spryker\Yves\Kernel\Container $container
	 *
	 * @return \Spryker\Yves\Kernel\Container
	 */
	protected function addMyPageFooBarWidgetPlugins(Container $container)
	{
		$container[self::PLUGIN_MY_PAGE_FOO_BAR_WIDGETS] = function () {
			return $this-&gt;getMyPageFooBarWidgetPlugins();
		};
 
		return $container;
	}
 
	/**
	 * @return string[]
	 */
	protected function getMyPageFooBarWidgetPlugins(): array
	{
		// activate list of widgets plugins for FooController:barAction()
		return [
			MyWidgetPlugin::class,
		];
	}
}</code></pre>
                        </p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot>Activate a widget in another widget</MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p><a name="activate_a_widget_in_another_widget"></a>In same cases it's necessary to extend widgets with other sub-widgets. The concept of nesting widgets in each other is the same as they were used in a Page, the only difference is how they are activated. You can activate sub-widgets in the <code>initialize()</code> method of any widget.</p>
                        <p>Those widgets that were activated in a controller are not available in other widgets. Every rendered Page and Widget have their own scope of twig variables and available widgets.</p>
                        <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\MyWidget\Plugin\MyPage;
 
use Pyz\Yves\MyPage\Dependency\Plugin\MyWidget\MyWidgetPluginInterface;
use Spryker\Yves\Kernel\Widget\AbstractWidgetPlugin;
 
/**
 * @method \Pyz\Yves\MyWidget\MyPageWidget getFactory()
 */
class MyWidgetPlugin extends AbstractWidgetPlugin implements MyWidgetPluginInterface
{
	/**
	 * @param string $myMandatoryParam
	 * @param int|null $myOptionalParam
	 *
	 * @return void
	 */
	public function initialize(string $myMandatoryParam, int $myOptionalParam = null): void
	{
		// activate list of sub-widgets
		$this-&gt;addWidgets($this-&gt;getFactory()-&gt;getMyWidgetSubWidgets());
	}
 
	// ...
}</code></pre>
                        </p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
                <MadCap:dropDown>
                    <MadCap:dropDownHead>
                        <MadCap:dropDownHotspot>Activate a widget to be available globally </MadCap:dropDownHotspot>
                    </MadCap:dropDownHead>
                    <MadCap:dropDownBody>
                        <p><a name="Activate_a_widget_to_be_available_globally"></a>Widgets available globally are activated in a central place, in the dependency provider of <code>ShopApplication</code> module. Only these widgets can be reached with the <code>widgetGlobal()</code> twig functions.</p>
                        <p><pre><code class="language-PHP line-numbers">&lt;?php
 
namespace Pyz\Yves\ShopApplication;
 
use SprykerShop\Yves\ShopApplication\ShopApplicationDependencyProvider as SprykerShopApplicationDependencyProvider;
 
class ShopApplicationDependencyProvider extends SprykerShopApplicationDependencyProvider
{
	/**
	 * @return string[]
	 */
	protected function getGlobalWidgetPlugins(): array
	{
		return [
			// list of active global widgets
		];
	}
}</code></pre>
                        </p>
                    </MadCap:dropDownBody>
                </MadCap:dropDown>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>&#160;</p>
        <p><i>Last review date: Feb 06th, 2019</i>
            <MadCap:conditionalText MadCap:conditions="General.Hidden Comment">by Tamás Nyulas, Oksana Karasyova</MadCap:conditionalText>
        </p>
    </body>
</html>