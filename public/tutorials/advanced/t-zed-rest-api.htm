<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="General.Draft">
    <head>
        <link href="../../Resources/TableStyles/PatternedRows.css" rel="stylesheet" MadCap:stylesheetType="table" />
    </head>
    <body>
        <h1>Tutorial - Zed Rest API</h1>
        <p>
            <img src="../../Resources/Images/shoptype/B2B_Shop.png" />
            <img src="../../Resources/Images/shoptype/B2C_Shop.png" />
            <img src="../../Resources/Images/shoptype/MasterSuite.png" />
            <img src="../../Resources/Images/shoptype/Demoshop.png" />
        </p>
        <p MadCap:conditions="General.Hidden Comment">used to be: http://spryker.github.io/challenge/zed-restapi/</p>
        <h2>Challenge Description</h2>
        <p>Spryker-based shop exposes module business logic through a simple API in Zed. The API is self-documented and can be easily explored for each module.</p>
        <p><strong>Bonus challenge</strong>
        </p>
        <ul>
            <li class="bullet_list">Create a simple client library to authorize and talk to Zed through API.</li>
            <li class="bullet_list">Extract the controller endpoint from Zed authorization or provide another authorization mechanism.</li>
        </ul>
        <h2>Challenge Solving Highlights</h2>
        <p><strong>Preparation</strong>
        </p>
        <p>As basis for solution we will use an idea of exposing facade methods through HTTP. Each module provides a stateless public interface, which operates either by using scalar types or transfer objects. We can dynamically examine this API using PHP Reflection and expose it through a Zed controller. This will require to be authorized in Zed, which is fine for a demo challenge, as a bonus challenge one might implement a separate authentication for the API endpoint.</p>
        <p>Transfer objects can de-serialise from JSON, this will simplify transport layer.</p>
        <p class="important">Reflection is used here for educational purposes, blindly exposing internal code structure in production might lead to security-related consequences.</p>
        <p><strong>Topics involved into solution</strong>
        </p>
        <p>It is advised to recap the following topics before starting the challenge:</p>
        <ul>
            <li class="bullet_list"><a href="http://php.net/manual/en/book.reflection.php" target="_blank" title="PHP reflection" alt="PHP reflection">PHP Reflection</a>
            </li>
            <li class="bullet_list">Facades</li>
            <li class="bullet_list">Transfer objects</li>
            <li class="bullet_list">
                <MadCap:xref href="t-add-new-bundle.htm">Tutorial - Adding a New [%=General.bundle/module%]</MadCap:xref>
            </li>
            <li class="bullet_list">Controllers in Zed</li>
        </ul>
        <p><strong>Plan of solving the challenge</strong>
        </p>
        <ol>
            <li>Create a simple Zed module with controller</li>
            <li>Create a business model to examine facade classes using Reflection. This will serve as self-documnted API and will allow to help with it</li>
            <li>Create a business model to examine transfer objects using Reflection</li>
            <li>Implement an “execute” controller action, which will proxy calls to specific methods of a facade and pass all the arguments to it</li>
        </ol>
        <h2>Step by step solution</h2>
        <p class="info">Code snippets below are stripped of doc strings and comments to minimize footprint, it is advised to always correctly specify method signatures to take advantage of IDE autocompletion.</p>
        <h3>Step 1: Create a simple Zed Module with controller</h3>
        <p>Creating a new module <code>Api</code> in <code>Pyz/Zed</code> scope. </p>
        <p>It is a good practice to version an API, so create a controller <code>V1Controller</code> in this module. At this point, the module contains one file – the controller, and looks as follows:</p><pre><code class="language-PHP line-numbers">Pyz/Zed
|__ Api
    |__ Communication
        |__ Controller
            |__ V1Controller.php</code></pre>
        <p>Actions can be empty and just returning some random string.</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Api\Communication\Controller;

use Symfony\Component\HttpFoundation\Request;
use Spryker\Zed\Kernel\Communication\Controller\AbstractController;

class V1Controller extends AbstractController
{
    // This action will be used to show documentation of a facade.
    public function docAction(Request $request)
    {
        return 'docAction';
    }
    // This action will be used to show documentation of a transfer object.
    public function docTransferAction(Request $request)
    {
        return 'docTransferAction';
    }
}</code></pre>
        <p>After this step log in to Zed and try opening <a href="http://zed_host/api/v1/doc" target="_blank" title="http://zed_host/api/v1/doc" alt="http://zed_host/api/v1/doc">http://ZED_HOST/api/v1/doc</a> and <a href="http://zed_host/api/v1/docTransfer" target="_blank" title="http://zed_host/api/v1/docTransfer" alt="http://zed_host/api/v1/docTransfer">http://ZED_HOST/api/v1/docTransfer</a>.</p>
        <h3>Step 2: Create a business model to examine facade classes using Reflection</h3>
        <p>First it is needed to create an empty model class <code>ApiEntry</code> in the business layer, it can be placed at <code>Business/Model/ApiEntry.php</code>.</p>
        <p>This class must be created in a factory of the module. Additionally the factory must provide additional dependencies from facades of other modules. To simplify the solution, facades can be created dynamically based on <code>GET</code> parameters of the request, while in real life it is advised to always specify these dependencies implcicitely.</p>
        <p>Considering all of above, the factory implementation can look like this:</p><pre xml:space="preserve"><code class="bash">&lt;?php
namespace Pyz\Zed\Api\Business;

use Pyz\Zed\Api\Business\Model\ApiEntry;
use Spryker\Zed\Kernel\Business\AbstractBusinessFactory;

class ApiBusinessFactory extends AbstractBusinessFactory
{
    // Here we will dynamically create facades of modules based on a module name.
    protected function getBundleFacade($bundle)
    {
        $locator = $this-&gt;createContainer()-&gt;getLocator();
        return $locator-&gt;$bundle()-&gt;facade(); 
    }
    // This instantiates our business model and passes the facade inside it.
    public function createFacadeProxy($bundle)
    {
        return new ApiEntry(
            $this-&gt;getBundleFacade($bundle)
        );
    }
}</code></pre>
        <p>Now implement the <code>__construct</code> method of <code>ApiEntry</code> to receive a facade and add an empty endpoint to be used in controller:</p><pre><code class="language-PHP line-numbers">&lt;?php
...
class ApiEntry
...
    protected $wrappedFacade;
    
    public function __construct(AbstractFacade $wrappedFacade)
    {
        $this-&gt;wrappedFacade = $wrappedFacade;
    }

    public function getAnnotations()
    {
        // TODO
    }</code></pre>
        <p><code>getAnnotations</code> method of the model must be exposed through the facade of the Àpi`module, before it can be used in the controller we prepared in the previous step:</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Api\Business;

use Spryker\Zed\Kernel\Business\AbstractFacade;

class ApiFacade extends AbstractFacade implements ApiFacadeInterface
{
    public function getAnnotations($bundle)
    {
        return $this-&gt;getFactory()-&gt;createFacadeProxy($bundle)-&gt;getAnnotations();
    }
}</code></pre>
        <p>After this we can call the method from the controller and think about implementing the business logic of the <code>ApiEntry</code> class:</p><pre><code class="language-PHP line-numbers">&lt;?php
...
class V1Controller extends AbstractController
...
    public function docAction(Request $request)
    {
        return [
            'annotations' =&gt; $this-&gt;getFacade()-&gt;getAnnotations($request-&gt;get('bundle'))
        ];
    }</code></pre>
        <p>And template for this action <code>Presentation/V1/doc.twig</code>:</p><pre><code class="language-PHP line-numbers">{{ dump() }}</code></pre>
        <p>Now the controller should work, but will return empty values, we can start implementing the business logic. To dynamically read documentation from facade we will use <code>ReflectionClass</code> of standard PHP library, the idea is to go through public methods, extract doc-strings and parameter types and render them on the page. This will result in self-documenting API. The final version of the <code>ApiEntry</code> for this step will look like:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Api\Business\Model;
use Spryker\Zed\Kernel\Business\AbstractFacade;
use ReflectionClass;
use ReflectionMethod;
use ReflectionType;

class ApiEntry
{
    protected $wrappedFacade;
    
    public function __construct(AbstractFacade $wrappedFacade)
    {
        $this-&gt;wrappedFacade = $wrappedFacade;
    }
    
    public function getAnnotations()
    {
        $className = get_class($this-&gt;wrappedFacade); // Locator returns an instance, reflection needs a class name.
        $reflection = new ReflectionClass($className);
        return $this-&gt;getPublicInterfaceAnnotations($reflection);
    }
    
    protected function getPublicInterfaceAnnotations(ReflectionClass $reflection)
    {
        $result = [];
        // Go through all public methods of the facade.
        foreach ($reflection-&gt;getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
            // Docstring lookup in interfaces implemented by the facade.
            $docDomment = $method-&gt;getDocComment();
            if (stripos($docDomment, '@inheritdoc') !== false) {
                foreach ($reflection-&gt;getInterfaces() as $interface) {
                    if ($interface-&gt;hasMethod($method-&gt;getName())) {
                        $docDomment = $interface-&gt;getMethod($method-&gt;getName())-&gt;getDocComment();
                        break;
                    }
                }
            }
            // As result we build an array from the doc-string and parameters.
            $result[$method-&gt;getName()] = [
                'docString' =&gt; $docDomment,
                'parameters' =&gt; $this-&gt;annotateIncomingParameters($method),
            ];
        }

        return $result;
    }
    
    protected function annotateIncomingParameters(ReflectionMethod $method)
    {
        $result = [];
        foreach ($method-&gt;getParameters() as $parameter) {
            $result[$parameter-&gt;getName()] = $this-&gt;annotateType($parameter-&gt;getType(), $parameter-&gt;getClass());
        }
        return $result;
    }
    protected function annotateType(ReflectionType $type = null, ReflectionClass $class = null)
    {
        return [
            'type' =&gt; $class !== null ? $class-&gt;getName() : $type,
            'isTransfer' =&gt; $class !== null ? $class-&gt;isSubclassOf('Spryker\Shared\Transfer\AbstractTransfer') : false,
        ];
    }

}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>The resulting structure of the array is following:</p><pre><code class="language-PHP line-numbers">[
  "methodName" =&gt; [
      'docString' =&gt; 'abc',
      'parameters' =&gt; ['parameterName' =&gt; ['type' =&gt; 'string', 'isTransfer' =&gt; false  ] ],
  ],
]</code></pre>
        <p>Now modify template to output the array:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;html&gt;
    &lt;table border="1"&gt;
        &lt;thead&gt;
            &lt;tr&gt;&lt;td&gt;Method&lt;/td&gt;&lt;td&gt;Annotation&lt;/td&gt;&lt;td&gt;Parameters&lt;/td&gt;&lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% for method, annotation in annotations %}
            &lt;tr&gt;
                &lt;td&gt;{{ method | nl2br}}&lt;/td&gt;
                &lt;td&gt;{{ annotation.docString | nl2br }}&lt;/td&gt;
                &lt;td&gt;
                    {% for parameter_name, parameter_annotation in annotation.parameters %}
                        {{ parameter_name }}:
                        {% if parameter_annotation.isTransfer %}
                            &lt;a href="docTransfer?transfer={{ parameter_annotation.type | escape}}" target="_blank"&gt;
                        {% endif %}
                        {{ parameter_annotation.type }}
                        {% if parameter_annotation.isTransfer %}
                            &lt;/a&gt;
                        {% endif %}
                        &lt;/br&gt;
                    {% endfor %}
                &lt;/td&gt;
            &lt;/tr&gt;
        {% endfor %}
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/html&gt;</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>Open <a href="http://zed_host/api/v1/doc?bundle=customerGroup" target="_parent" title="http://zed_host/api/v1/doc?bundle=customerGroup" alt="http://zed_host/api/v1/doc?bundle=customerGroup">http://ZED_HOST/api/v1/doc?bundle=customerGroup</a> to see the results.</p>
        <h3>Step 3: Create a business model to examine transfer objects using Reflection</h3>
        <p>Now let us repeat everything from the previous step, but for a new model <code>TransferAnnotator</code>, which we will use to annotate transfer objects. The model should implement a method <code>public function annotate($transfer)</code>, it should be exposed through the facade of the module and used in the <code>docTransferAction</code>, which we prepared in the controller.</p>
        <p class="info"><strong>Attention</strong>
            <br />Transfer objects have a private propery transferMetadata, which describes all the fields, the easiest is to read it for exercise purposes.</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Api\Business\Model;
use ReflectionClass;
class TransferAnnotator implements TransferAnnotatorInterface
{
    public function annotate($transfer)
    {
        $reflection = new ReflectionClass($transfer);
        $metadata = $reflection-&gt;getDefaultProperties()['transferMetadata'];
        $result = [];
        foreach ($metadata as $attribute =&gt; $properties) {
            $result[$attribute] = print_r($properties, true);
        }
        return $result;
    }
}</code></pre>
        <p>Template <code>doc-transfer.twig</code>:</p><pre><code class="language-PHP line-numbers">&lt;html&gt;
    &lt;table border="1"&gt;
        &lt;thead&gt;
            &lt;tr&gt;&lt;td&gt;Property&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
        {% for name, annotation in transfer_annotation %}
            &lt;tr&gt;
                &lt;td&gt;{{ name | nl2br}}&lt;/td&gt;
                &lt;td&gt;{{ annotation | nl2br }}&lt;/td&gt;
            &lt;/tr&gt;
        {% endfor %}
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/html&gt;</code></pre>
        <p>After completing this step we should be able to see transfer object annotation by accessing <a href="http://zed_host/api/v1/docTransfer?transfer=Generated\Shared\Transfer\CustomerGroupTransfer" target="_blank">http://ZED_HOST/api/v1/docTransfer?transfer=Generated\Shared\Transfer\CustomerGroupTransfer</a>.</p>
        <h3>Step 4: Implement an “execute” controller action, which will proxy calls to specific methods of a facade and pass all the arguments to it</h3>
        <p>This step is not directly related to Spryker but to an idea to cast incoming parameters to types based on method signature dynamically and forward a call to respective facade method. The big advantage is that Spryker allows to unserialise transfer objects from JSON, it means, we can just send values for complex objects as JSON objects and those can be automatically casted to transfer objects and be safely used, when calling different facade methods.</p>
        <p>Let us extend <code>ApiEntry</code> with:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
...
    public function forwardCall($name, array $arguments)
    {
        if (method_exists($this-&gt;wrappedFacade, $name)) {
            return call_user_func_array([$this-&gt;wrappedFacade, $name], $this-&gt;castArguments($name, $arguments));
        }
        throw new \BadMethodCallException('Non-existing method ' . get_class($this-&gt;wrappedFacade) . '::' . $name);
    }
    protected function castArguments($methodName, array $arguments = [])
    {
        $className = get_class($this-&gt;wrappedFacade);
        $reflection = new ReflectionClass($className);
        $parameters = $this-&gt;annotateIncomingParameters($reflection-&gt;getMethod($methodName));
        $result = [];
        foreach ($parameters as $name =&gt; $annotation) {
            // Here JSON is casted to transfer object.
            if ($annotation['isTransfer']) {
                $class = $annotation['type'];
                /** @var \Spryker\Shared\Kernel\Transfer\AbstractTransfer $transfer */
                $transfer = new $class();
                $transfer-&gt;unserialize($arguments[$name]);
                $result[$name] = $transfer;
            } else {
                $result[$name] = $arguments[$name];
            }
        }
        return $result;
    }</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>Publish this mehthod in the facade of our module and add a controller method to forward the call and render the result of the call. Let us just convert the return values to JSON for simplicity, new methods of <code>V1Controller</code> may look like:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
...
use Spryker\Shared\Kernel\Transfer\AbstractTransfer;
use Symfony\Component\HttpFoundation\JsonResponse;
...
    public function executeAction(Request $request)
    {
        return new JsonResponse($this-&gt;resultToArray(
            $this-&gt;getFacade()-&gt;callBundleMethod(
                $request-&gt;get('bundle'),
                $request-&gt;get('method'),
                $request-&gt;get('arguments', [])
            )
        ));
    }
    protected function resultToArray($mixed)
    {
        if (is_scalar($mixed)) {
            return $mixed;
        }
        if ($mixed instanceof AbstractTransfer) {
            return $mixed-&gt;toArray(true);
        }
        if (is_array($mixed)) {
            $result = [];
            foreach ($mixed as $key =&gt; $value) {
                $result[$key] = $this-&gt;resultToArray($value);
            }
            return $result;
        }
        if ($mixed === null) {
            return null;
        }
        throw new \InvalidArgumentException();
    }
    </code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h3>Testing</h3>
        <p>Finally the challenge is finished, now we can finally play with our API, here are a couple of example of calling the facade of CustomerGroup module:</p><pre><code class="language-PHP line-numbers">-&gt; http://ZED_HOST/api/v1/execute?bundle=customerGroup&amp;method=add&amp;arguments[customerGroupTransfer]={%22name%22:%22test98597435%22}

&lt;- {"id_customer_group":13,"name":"test98597435","description":null,"customers":{}}

-&gt; http://ZED_HOST/api/v1/execute?bundle=customerGroup&amp;method=get&amp;arguments[customerGroupTransfer]={%22idCustomerGroup%22:1}

&lt;- {"id_customer_group":1,"name":"test","description":null,"customers":{}}</code></pre>
        <h2>To sum up</h2>
        <p>In this challenge we implemented self-documenting API based on a public API of modules, we learned how to use Reflection in PHP, extend Zed, forward calls dynamically to different facades and how Spryker powerful and flexible is regarding public API and boundaries of modules.</p>
        <h2>References</h2>
        <table class="TableStyle-PatternedRows" style="mc-table-style: url('../../Resources/TableStyles/PatternedRows.css');" cellspacing="0">
            <col class="TableStyle-PatternedRows-Column-Regular" />
            <col class="TableStyle-PatternedRows-Column-Regular" />
            <thead>
                <tr class="TableStyle-PatternedRows-Head-Header1">
                    <th class="TableStyle-PatternedRows-HeadE-Regular-Header1">Documentation</th>
                    <th class="TableStyle-PatternedRows-HeadD-Regular-Header1">Description</th>
                </tr>
            </thead>
            <tbody>
                <tr class="TableStyle-PatternedRows-Body-LightRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-LightRows">
                        <p><a href="http://php.net/manual/en/book.reflection.php" target="_blank" title="PHP reflection" alt="PHP reflection">PHP Reflection</a>
                        </p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-LightRows">
                        <p>Reflection in PHP</p>
                    </td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-DarkerRows">
                        <p>Facades	</p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-DarkerRows">
                        <p>Facades in Spryker</p>
                    </td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-LightRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-LightRows">
                        <p>Transfer objects</p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-LightRows">
                        <p>Transfer Objects in Spryker</p>
                    </td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-DarkerRows">
                        <p>
                            <MadCap:xref href="t-add-new-bundle.htm">Tutorial - Adding a New Module</MadCap:xref>
                        </p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-DarkerRows">
                        <p>Creating a new Module</p>
                    </td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-LightRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-LightRows">
                        <p>Controllers in Zed</p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-LightRows">
                        <p>	Developing controllers in ZED</p>
                    </td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows-BodyB-Regular-DarkerRows">
                        <p>Twig syntax reference</p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyA-Regular-DarkerRows">
                        <p>Twig syntax reference</p>
                    </td>
                </tr>
            </tbody>
        </table>
    </body>
</html>