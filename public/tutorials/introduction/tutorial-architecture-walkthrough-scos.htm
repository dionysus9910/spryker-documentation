<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <h1>Tutorial - Architectural Walkthrough - <MadCap:variable name="General.ProductName" /></h1>
        <p class="info">This tutorial is also available on the Spryker Training web-site. For more information and hands-on exercises, visit the <a href="https://training.spryker.com/courses/developer-bootcamp">Spryker Training</a> web-site.</p>
        <p>The main idea of this task is to understand the Spryker architecture and how things work all together. </p>
        <p>We will implement a very simple functionality in the back-end application to reverse a string. Then we will let the front-end application connect to the back-end one in order to use this functionality and show the result on a webpage in the shop.</p>
        <h2>Challenge Description</h2>
        <ul>
            <li>Build a <b>HelloSpryker</b> module in Zed that will render the "Hello Spryker!" string in <MadCap:expanding><MadCap:expandingHead>reverse order</MadCap:expandingHead><MadCap:expandingBody>"!rekyrpS olleH"</MadCap:expandingBody></MadCap:expanding> on the screen.</li>
            <li>Build a <b>HelloSpryker</b> module in Yves that communicates with Zed using the Client to retrieve the same <MadCap:expanding><MadCap:expandingHead>reversed string</MadCap:expandingHead><MadCap:expandingBody>"!rekyrpS olleH" </MadCap:expandingBody></MadCap:expanding> and shows on a webpage in the shop.</li>
            <li>Add Zed persistence layer in <b>HelloSpryker</b> module to store and get the reversed string to and from the database.</li>
            <li>Move the functionality that returns the reversed string to a new module (<i>StringFormat</i>), then provide the string to the <b>HelloSpryker</b> module. </li>
        </ul>
        <p class="info">This means building a dependency from the HelloSpryker module to the StringFormat one.</p>
        <h2>Challenge Solving Highlights</h2>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>1. Build the HelloSpryker module in Zed to reverse the string</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <ol>
                    <li>
						To add a new module in Zed, go to <code>/src/Pyz/Zed</code> and add a new folder called <i>HelloSpryker</i>.
                        <p class="info">A new module is simply a new folder.</p></li>
                    <li>The communication layer in a module is its entry point, so we will add it first and check if your <a name="module_"></a>module responds:
							<p>1. Create a new folder under <i>HelloSpryker</i> called <b>Communication</b>.</p><p>2. Create a folder called <b>Controller</b> inside the <b>Communication</b> folder.</p><p>3. Create a new controller called <code>IndexController</code>. This controller has an action that returns only "HelloSpryker!" for now:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Zed\HelloSpryker\Communication\Controller;
								
use Spryker\Zed\Kernel\Communication\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
 
class IndexController extends AbstractController
{
	/**
	* @param Request $request
	*
	* @return array
	*/
	public function indexAction(Request $request)
	{
	return ['string' =&gt; 'Hello Spryker!'];
	}
}						
						</code></pre></p></li>
                    <li>To render the text in the Zed UI template, add the presentation layer with the twig file that loads as the action's response.
						<p>1. Add a new folder called <b>Presentation</b>.</p><p>2. Inside it add a folder for the controller and the twig file for the action. So this would be: <code>Index/index.twig</code>.</p><p>The twig file for your action looks like this:</p><p><pre><code class="language-PHP line-numbers">
{% extends '@Gui/Layout/layout.twig' %}
{% block content %}
	{{ string }}
{% endblock %}																			
						</code></pre></p></li>
                    <li>To see "Hello Spryker!", go to <a href="http://zed.de.suite.local/hello-spryker">http://zed.de.suite.local/hello-spryker</a>.</li>
                </ol>
                <p>As reversing a string belongs to the business logic, you need to build a Business layer for your module.</p>
                <ol>
                    <li>Add a folder called <i>Business</i> inside the <b>HelloSpryker</b> module.</li>
                    <li>Business layer needs three main classes:
					<ul><li><b><a href="#facade_class">Facade</a></b> to work as the main API</li><li><b><a href="#factory">Factory</a></b> to instantiate the needed objects and inject their dependencies</li><li><b><a href="#model_folder">Model</a></b> to perform the actual business logic</li></ul><p>Following that, first build the <a name="facade_class"></a>facade class, and don't forget the facade interface:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Zed\HelloSpryker\Business;
 
use Spryker\Zed\Kernel\Business\AbstractFacade;
 
class HelloSprykerFacade extends AbstractFacade implements HelloSprykerFacadeInterface
{
	// Your code goes here
}
						</code></pre></p><p>Second, add the <a name="factory"></a>factory:</p><p><pre><code class="language-PHP line-numbers">
	namespace Pyz\Zed\HelloSpryker\Business;
 
use Pyz\Zed\HelloSpryker\Business\Model\StringReverser;
use Spryker\Zed\Kernel\Business\AbstractBusinessFactory;
 
class HelloSprykerBusinessFactory extends AbstractBusinessFactory
{
	// Your code goes here
}
						</code></pre></p><p>And thirdly, add your <a name="model_folder"></a>model folder inside the business layer and add class to handle reversing the string. Call the method as <code>reverseString()</code>.</p><p class="info">To reverse the string, you can simply use method <code>strrev()</code>.</p></li>
                </ol>
                <p>It's time to hook things together.</p>
                <ol>
                    <li>Instantiate an object from your class in the factory and let a facade method use the new factory method in order to get the needed object. Then call the <code>reverseString()</code> method from the object.
					<p>Your facade method should look like this:</p><p><pre><code class="language-PHP line-numbers">
/**
* @return StringReverser
*/
public function createStringReverser()
{
	return new StringReverser();
}						
									</code></pre></p><p><pre><code class="language-PHP line-numbers">
/**
* @param string $originalString
*
* @return string
*/
public function reverseString($originalString)
{
	return $this-&gt;getFactory()
		-&gt;createStringReverser()
		-&gt;reverseString($originalString);
}					
						</code></pre></p></li>
                    <li>Finally, let's call the facade method from the controller <a href="#module_">we built in the very begging</a>.
                    <p><pre><code class="language-PHP line-numbers">
/**
* @param Request $request
*
* @return array
*/
public function indexAction(Request $request)
{
	$originalString = "Hello Spryker!";
	$reversedString = $this-&gt;getFacade()-&gt;reverseString($originalString);
     
	return ['string' =&gt; $reversedString];
}
					</code></pre></p><p>To summarize, when accessing a URL in Zed UI the action responds to the requests, then it calls the facade which finally calls the model to perform the needed business logic.</p></li>
                    <li>Go to <a href="http://zed.de.suite.local/hello-spryker">http://zed.de.suite.local/hello-spryker</a> to see "!rekyrpS olleH"</li>
                </ol>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>2. Build the HelloSpryker module in Yves</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <ol>
                    <li>Add a new Yves module called <b>HelloSpryker</b> in <code>/src/Pyz/Yves</code>.</li>
                    <li>Add a new controller for the module.
					<ol><li>Add a new folder called <i>Controller</i> inside the <b>HelloSpryker</b> module.</li><li>Add the following controller class called <code>IndexController</code>:</li><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Yves\HelloSpryker\Controller;
 
use Generated\Shared\Transfer\HelloSprykerTransfer;
use Spryker\Yves\Kernel\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
 
	/**
	* @method \Pyz\Client\HelloSpryker\HelloSprykerClientInterface getClient()
	*/
	class IndexController extends AbstractController
	{
	/**
	* @param Request $request
	*
	* @return \Spryker\Yves\Kernel\View\View
	*/
	public function indexAction(Request $request)
	{
		$data = ['reversedString' =&gt; 'Hello Spryker!'];
 
		return $this-&gt;view(
			$data,
			[],
			'@HelloSpryker/views/index/index.twig'
		);
	}
}
							</code></pre></p></ol></li>
                    <li>Add the route to the controller:
					<ol><li>Add a new folder inside the <b>HelloSpryker</b> module called <i>Plugin</i>,</li><li>Inside the <i>Plugin</i> folder, add a folder called <i>Provider</i>.</li><li>Add your <code>ControllerProvider</code> class with the name <code>HelloSprykerControllerProvider</code>:</li><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Yves\HelloSpryker\Plugin\Provider;
 
use Silex\Application;
use SprykerShop\Yves\ShopApplication\Plugin\Provider\AbstractYvesControllerProvider;
 
class HelloSprykerControllerProvider extends AbstractYvesControllerProvider
{
	const HELLO_SPRYKER_INDEX = 'hello-spryker-index';
 
	/**
	* @param \Silex\Application $app
	*
	* @return void
	*/
	protected function defineControllers(Application $app)
	{
		$this-&gt;createGetController('/hello-spryker', static::HELLO_SPRYKER_INDEX, 'HelloSpryker', 'Index', 'index');
	}
}
							</code></pre></p></ol></li>
                    <li>Register the <code>ControllerProvider</code> in the application, so the application knows about your controller action. 
					<p>Go to <code>YvesBootstrap::getControllerProviderStack</code> method in <b>ShopApplication</b> module and add <code>HelloSprykerControllerProvider</code> to the array.</p></li>
                    <li>Finally add the twig file to render your Hello Spryker page.
					<p>Add the following folder structure inside the <b>HelloSpryker</b> module: <code>Theme/default/views/index</code>.</p><p>This folder structure reflects your theme and controller names. Default is the theme name, and index is the controller name. For every action there is a template with the same name.</p><p>As your action is called <i>index</i>, add a twig file for your action called <code>index.twig</code>:</p><p><pre><code class="language-PHP line-numbers">
{% extends template('page-layout-main') %}
 
{% define data = {
	reversedString: _view.reversedString
} %}
 
{% block content %}
	&lt;div&gt;&lt;h2&gt;{{ data.reversedString }}&lt;/h2&gt;&lt;/div&gt;
{% endblock %}
						</code></pre></p></li>
                </ol>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>3. Create HelloSpryker transfer object and use it</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Transfer objects are a great way to send data from Yves to Zed, and for communication between different objects in general. Transfer object definitions are located in Shared directories as these objects are shared between Yves and Zed.</p>
                <ol>
                    <li>To add a HelloSpryker transfer, add a new folder inside <code>/src/Shared</code> and call it <i>HelloSpryker</i>. Then add another folder called <i>Transfer</i>.</li>
                    <li>Transfer objects utilize XML to define their schemas. Add an XML file inside <i>Transfer</i> directory and call it <code>hello_spryker.transfer.xml</code> then add the following transfer schema:
					<p><pre><code class="language-PHP line-numbers">
&lt;?xml version="1.0"?&gt;
&lt;transfers xmlns="spryker:transfer-01"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="spryker:transfer-01 http://static.spryker.com/transfer-01.xsd"&gt;
     
	&lt;transfer name="HelloSpryker"&gt;
		&lt;property name="originalString" type="string" /&gt;
		&lt;property name="reversedString" type="string" /&gt;
		&lt;/transfer&gt;
&lt;/transfers&gt;
						</code></pre></p></li>
                    <li>Run the console command: <code>console transfer:generate</code>.
					<p>The transfer object is generated and ready to use.</p></li>
                    <li>Update the <b>Facade</b> to use the transfer object instead of string as a parameter:
					<p><pre><code class="language-PHP line-numbers">
/**
* @param HelloSprykerTransfer $helloSprykerTransfer
*
* @return HelloSprykerTransfer
*/
public function reverseString(HelloSprykerTransfer $helloSprykerTransfer)
{
	return $this-&gt;getFactory()
		-&gt;createStringReverser()
		-&gt;reverseString($helloSprykerTransfer);
}
									</code></pre></p></li>
                    <li>Update your model and <code>IndexController</code> accordingly.</li>
                    <p class="info">You should still get "!rekyrpS olleH" when accessing <a href="http://zed.de.suite.local/hello-spryker">http://zed.de.suite.local/hello-spryker</a>.</p>
                </ol>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>4. Build a HelloSpryker Client to connect Yves to Zed</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>To build the communication between Yves and Zed, we need the <b>Client</b>. Building a client for <i>HelloSpryker</i> is similar to building a module in Zed or Yves. </p>
                <ol>
                    <li>Add a new folder under <code>/src/Pyz/Client</code> and call it <i>HelloSpryker</i>.</li>
                    <li>The Client structure consists also of three main classes: 
					<ul><li><b><a href="#client_class">Client</a></b> to function as the main API to the clilent</li><li><b><a href="#factory_1">Factory</a></b>  to instantiate the needed objects and inject their dependencies</li><li><b><a href="#stub">Stub</a></b> to do the actual call to Zed with the right payload.</li></ul><p>Create the <a name="client_class"></a>client class inside the <i>HelloSpryker</i> client folder like this:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Client\HelloSpryker;
 
use Spryker\Client\Kernel\AbstractClient;
 
class HelloSprykerClient extends AbstractClient implements HelloSprykerClientInterface
{
	// Your code goes here
}		
									</code></pre></p><p>Now add the <a name="factory_1"></a>factory:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Client\HelloSpryker;
 
use Pyz\Client\HelloSpryker\Zed\HelloSprykerStub;
use Spryker\Client\Kernel\AbstractFactory;
 
class HelloSprykerFactory extends AbstractFactory
{
	// Your code goes here
}
						</code></pre></p><p>Then add the <a name="stub"></a>stub. As the client is calling Zed, create a folder called <i>Zed</i> and add the stub inside it:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Client\HelloSpryker\Zed;
 
use Spryker\Client\ZedRequest\Stub\ZedRequestStub;
 
class HelloSprykerStub extends ZedRequestStub implements HelloSprykerStubInterface
{
	// Your code goes here
}									
									</code></pre></p></li>
                    <li>Add the class <code>HelloSprykerDependencyProvider</code> inside the <b>HelloSpryker</b> module in order to provide the <i>ZedRequest Client</i> to our <i>HelloSpryker Client</i>.
					<div class="info">Any client that calls Zed from Yves uses the <b>ZedRequest</b> module. This module is responsible, as the name suggest, for the request to Zed from Yves, and uses its own client to do so. The client name is <b>ZedRequest Client</b>. 
						<p>Following the modular approach in Spryker, all other modules need to use the ZedRequest Client whenever a request is to be sent to Zed from Yves.</p><p>As <b>ZedRequest</b> is a separated module, a dependency is needed between the calling module, HelloSpryker in our case, and ZedRequest module.</p><p>An architectural concept in Spryker called <code>DependencyProvider</code> is used to inject these dependencies between different modules.</p></div><p><pre><code class="language-PHP line-numbers">
									
namespace Pyz\Client\HelloSpryker;
 
use Spryker\Client\Kernel\AbstractDependencyProvider;
use Spryker\Client\Kernel\Container;
 
class HelloSprykerDependencyProvider extends AbstractDependencyProvider
{
	const CLIENT_ZED_REQUEST = 'CLIENT_ZED_REQUEST';
 
	/**
	 * @param \Spryker\Client\Kernel\Container $container
	 *
	 * @return \Spryker\Client\Kernel\Container
	 */
	public function provideServiceLayerDependencies(Container $container)
	{
		$container = $this-&gt;addZedRequestClient($container);
 
		return $container;
	}
 
	/**
	 * @param \Spryker\Client\Kernel\Container $container
	 *
	 * @return \Spryker\Client\Kernel\Container
	 */
	protected function addZedRequestClient(Container $container)
	{
		$container[static::CLIENT_ZED_REQUEST] = function (Container $container) {
			return $container-&gt;getLocator()-&gt;zedRequest()-&gt;client();
		};
 
		return $container;
	}
}
									</code></pre></p><p>As the factory is responsible for dependency injection inside our module (the DependencyProvider on the other hand is responsible for the dependencies between modules and not inside one module), inject the ZedRequest Client into the stub using the factory:</p><p><pre><code class="language-PHP line-numbers">
/**
 * @return \Pyz\Client\HelloSpryker\Zed\HelloSprykerStubInterface
 */
public function createZedHelloSprykerStub()
{
	return new HelloSprykerStub($this-&gt;getZedRequestClient());
}
 
/**
 * @return \Spryker\Client\ZedRequest\ZedRequestClientInterface
 */
protected function getZedRequestClient()
{
	return $this-&gt;getProvidedDependency(HelloSprykerDependencyProvider::CLIENT_ZED_REQUEST);
}								
									</code></pre></p><p>Now, you have all the objects you need and the client is ready to call Zed.</p></li>
                    <li>Add a method to the stub to call Zed and pass the transfer object as a pay load like this:
					<p><pre><code class="language-PHP line-numbers">
/**
 * @param HelloSprykerTransfer $helloSprykerTransfer
 *
 * @return HelloSprykerTransfer|\Spryker\Shared\Kernel\Transfer\TransferInterface
 */
public function reverseString(HelloSprykerTransfer $helloSprykerTransfer)
{
	return $this-&gt;zedStub-&gt;call(
		'/hello-spryker/gateway/reverse-string',
		$helloSprykerTransfer
	);
}
									</code></pre></p><div class="info">This method will call the Zed module HelloSpryker. 
							<p>The first parameter in the <i>call()</i> method is the endpoint of the request which is divided into three main sections: <code>moduleName/controllerName/ActionName</code>. Here, we are calling the module <b>HelloSpryker</b>, the <i>GatewayController</i>, and the <i>ReverseStringAction</i>.</p><p>By convention, clients send requests to <i>GatewayControllers</i>. The second parameter is the payload of the request which is always a transfer object, any transfer object.</p></div></li>
                    <li>Add a client method in the <i>HelloSprykerClient</i> to call the <code>reverseString()</code> method in the stub.
<p><pre><code class="language-PHP line-numbers">
/**
 * @param HelloSprykerTransfer $helloSprykerTransfer
 *
 * @return HelloSprykerTransfer|\Spryker\Shared\Kernel\Transfer\TransferInterface
 */
public function reverseString(HelloSprykerTransfer $helloSprykerTransfer)
{
	return $this-&gt;getFactory()
		-&gt;createZedHelloSprykerStub()
		-&gt;reverseString($helloSprykerTransfer);
}									
									</code></pre></p><p>That's it from the client side.</p></li>
                </ol>
				Let's get everything hooked together:
				<ol><li>First, create the <i>GatewayController</i> in the communication layer of Zed, the one that responds to the client's request. 
<p><pre><code class="language-PHP line-numbers">
namespace Pyz\Zed\HelloSpryker\Communication\Controller;
 
use Generated\Shared\Transfer\HelloSprykerTransfer;
use Spryker\Zed\Kernel\Communication\Controller\AbstractGatewayController;
 
class GatewayController extends AbstractGatewayController
{
	/**
	 * @param HelloSprykerTransfer $helloSprykerTransfer
	 *
	 * @return HelloSprykerTransfer
	 */
	public function reverseStringAction(HelloSprykerTransfer $helloSprykerTransfer)
	{
		return $this-&gt;getFacade()
			-&gt;reverseString($helloSprykerTransfer);
	}
}									</code></pre></p></li><li>
						Second, call the client from the <i>IndexController</i> in Yves to reverse the string.
						<p><pre><code class="language-PHP line-numbers">
					
/**
 * @param \Symfony\Component\HttpFoundation\Request $request
 *
 * @return array|\Symfony\Component\HttpFoundation\RedirectResponse
 */
public function indexAction(Request $request)
{
	$helloSprykerTransfer = new HelloSprykerTransfer();
	$helloSprykerTransfer-&gt;setOriginalString('Hello Spryker!');
 
	$helloSprykerTransfer = $this-&gt;getClient()
		-&gt;reverseString($helloSprykerTransfer);
 
	return ['reversedString' =&gt; $helloSprykerTransfer-&gt;getRefersedString()];
}			
						</code></pre></p></li><li>Finally, update the twig template in Yves to use <i>reversedString</i>.</li></ol><p>Done! Now go to <a href="http://www.de.suite.local/hello-spryker">http://www.de.suite.local/hello-spryker</a>. You should see: "!rekyrpS olleH".</p></MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>5. Make HelloSpryker Module Read from Database</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <ol>
                    <li>Working with the database means working with the persistence layer in Zed. Go back to Zed and add a new folder inside the <b>HelloSpryker</b> module and call it <i>Persistence</i>. Inside <i>Persistence</i>, add the directories <i>Propel</i>/<i>Schema</i>.</li>
                    <li>Propel uses XML, thus Spryker uses XML as well. Inside the Schema directory, add the database XML schema file and call it <code>pyz_hello_spryker.schema.xml</code>:
					<p><pre><code class="language-PHP line-numbers">
&lt;?xml version="1.0"?&gt;
&lt;database xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	name="zed" xsi:noNamespaceSchemaLocation="http://static.spryker.com/schema-01.xsd"
	namespace="Orm\Zed\HelloSpryker\Persistence"
	namespaceAutoPackage="false"
	package="src.Orm.Zed.HelloSpryker.Persistence"&gt;
 
		&lt;table name="pyz_hello_spryker" idMethod="native"&gt;
			&lt;column name="id_hello_spryker" required="true" type="INTEGER" autoIncrement="true" primaryKey="true"/&gt;
			&lt;column name="reversed_string" required="true" size="128" type="VARCHAR"/&gt;
 
			&lt;id-method-parameter value="pyz_hello_spryker_pk_seq"/&gt;
		&lt;/table&gt;
&lt;/database&gt;
					</code></pre></p></li>
                    <li>Run the console command: <code>console propel:install</code>. Now you have the HelloSpryker table in the database.
					<p class="tip"> To make sure, open the database and check if the table is there.</p></li>
                    <li>Let's write the reversed string into the database. Modify your model in the Business layer to do so after reversing the string:
					<p><pre><code class="language-PHP line-numbers">
/**
 * @param HelloSprykerTransfer $helloSprykerTransfer
 *
 * @return void
 */
protected function saveReversedString(HelloSprykerTransfer $helloSprykerTransfer)
{
	$helloSprykerEntity = new PyzHelloSpryker();
 
	$helloSprykerEntity-&gt;setReversedString($helloSprykerTransfer-&gt;getReversedString())-&gt;save();
}	
					</code></pre></p></li>
                    <li>To read from the database, Spryker provides a concept called <i>QueryContainer</i>. It's the place where you create query objects to get data from the database. 
					<p>Inside the Persistence directory, create the <code>HelloSprykerPersistenceFactory</code> and <code>HelloSprykerQueryContainer</code>:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Zed\HelloSpryker\Persistence;
 
use Orm\Zed\HelloSpryker\Persistence\PyzHelloSprykerQuery;
use Spryker\Zed\Kernel\Persistence\AbstractPersistenceFactory;
 
class HelloSprykerPersistenceFactory extends AbstractPersistenceFactory
{
	/**
	 * @return PyzHelloSprykerQuery
	 */
	public function createHelloSprykerQuery()
	{
		return PyzHelloSprykerQuery::create();
	}
}									
</code></pre></p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Zed\HelloSpryker\Persistence;
 
use Spryker\Zed\Kernel\Persistence\AbstractQueryContainer;
 
class HelloSprykerQueryContainer extends AbstractQueryContainer implements HelloSprykerQueryContainerInterface
{
	/**
	 * @param $idHelloSpryker
	 *
     * @throws \Spryker\Zed\Propel\Business\Exception\AmbiguousComparisonException
	 *
	 * @return \Orm\Zed\HelloSpryker\Persistence\PyzHelloSprykerQuery
	 */
	public function queryHelloSprykerById($idHelloSpryker)
	{
		return $this-&gt;getFactory()
			-&gt;createHelloSprykerQuery()
			-&gt;filterByIdHelloSpryker($idHelloSpryker);
	}
 
	/**
	 * @api
	 *
	 * @return \Orm\Zed\HelloSpryker\Persistence\PyzHelloSprykerQuery
	 */
	public function queryHelloSpryker()
	{
		return $this-&gt;getFactory()
			-&gt;createHelloSprykerQuery();
	}
}									
</code></pre></p></li>
                    <li>Now, let the <i>IndexController</i> in Zed read from the database. 
					<p>To do so, add a facade method with a model to read and from the database in the business layer.</p><p>Call the model <i>StringReader</i>. Then call the facade method from the <i>IndexController</i> in the communication layer.</p><p>To read from the database, you need to inject the <i>HelloSprykerQueryContainer</i> inside the <i>StringReader</i> using the <i>HelloSprykerBusinessFactory</i> like this:</p><p><pre><code class="language-PHP line-numbers">
/**
 * @return StringReader
 */
public function createStringReader()
{
	 return new StringReader($this-&gt;getQueryContainer());
}						
</code></pre></p><p>And the <code>readString()</code>method looks like this:</p><p><pre><code class="language-PHP line-numbers">
/**
 * @param int $id
 *
 * @return HelloSprykerTransfer
 */
public function readString($id)
{
	$helloSprykerEntity = $this-&gt;helloSprykerQueryContainer
		-&gt;queryHelloSprykerById($id)
		-&gt;findOne();
 
	$helloSprykerTransfer = new HelloSprykerTransfer();
	$helloSprykerTransfer-&gt;fromArray($helloSprykerEntity-&gt;toArray(), true);
 
 
	return $helloSprykerTransfer;
}							
</code></pre></p></li>
                </ol>
                <p>Now go to <a href="http://zed.de.suite.local/hello-spryker">http://zed.de.suite.local/hello-spryker</a> to see "!rekyrpS olleH".</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>6. Bonus: HelloSpryker Module Dependency with StringReverser</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>The idea of this bonus task is to handle module dependency using the concept of Dependency Providers.</p>
                <p>As mentioned before, Dependency Providers provide dependencies in a module level, from one module to another. Mainly they provide facades and clients only.</p>
                <ol>
                    <li>One module can't access other classes form another module. To use Dependency Providers, create a new module in Zed and call it <i>StringReverser</i>.</li>
                    <li>Move the logic of reversing a string from <i>HelloSpryker</i> to <i>StringReverser</i>. 
					<p class="info">You need to build a business later inside <i>StringReverser</i> with a facade and a model to revers the string.</p></li>
                    <li>In the <b>HelloSpryker</b> module, create a dependency provider class and call it <i>HelloSprykerDependencyProvider</i>.</li>
                    <li>Provide the business layer dependency to the <b>HelloSpryker</b> module and internally use the <i>StringReverser</i> facade to provide the string reversing functionality. 
						<p>The <i>HelloSprykerDependencyProvider</i> will look like this:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Zed\HelloSpryker;
 
use Spryker\Zed\Kernel\AbstractBundleDependencyProvider;
use Spryker\Zed\Kernel\Container;
 
class HelloSprykerDependencyProvider extends AbstractBundleDependencyProvider
{
	const FACADE_STRING_REVERSER = 'FACADE_STRING_REVERSER';
 
	/**
	 * @param \Spryker\Zed\Kernel\Container $container
	 *
	 * @return \Spryker\Zed\Kernel\Container
	 */
	public function provideBusinessLayerDependencies(Container $container)
	{
		$container = $this-&gt;addStringReverserFacade($container);
 
		return $container;
	}
 
	/**
	 * @param \Spryker\Zed\Kernel\Container $container
	 *
	 * @return \Spryker\Zed\Kernel\Container
	*/
	protected function addStringReverserFacade(Container $container)
	{
		$container[static::FACADE_STRING_REVERSER] = function (Container $container) {
			return $container-&gt;getLocator()-&gt;stringReverser()-&gt;facade();
		};
 
		return $container;
	}
}									
</code></pre></p></li>
                    <li>Inject the dependency using the <code>HelloSprykerBusinessFactory</code>.
<p><pre><code class="language-PHP line-numbers">
/**
 * @return StringReverserFacade
 */
protected function getStringReverserFacade()
{
	return $this-&gt;getProvidedDependency(HelloSprykerDependencyProvider::FACADE_STRING_REVERSER);
}						
</code></pre></p></li>
                    <li>Use the <i>StringReverserFacade</i> to reverse the string instead of using the logic directly inside the <b>HelloSpryker</b> module.</li>
                </ol>
                <p>Go to <a href="http://zed.de.suite.local/hello-spryker">http://zed.de.suite.local/hello-spryker</a> and <a href="http://www.de.suite.local/hello-spryker">http://www.de.suite.local/hello-spryker</a>. You should see: "!rekyrpS olleH".</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>&#160;</p>
        <p><i>Last review date: Jul 20, 2018 </i>
            <MadCap:conditionalText MadCap:conditions="General.Hidden Comment" style="font-style: italic;">by Hussam Hebbo, Anastasija Datsun</MadCap:conditionalText>
        </p>
    </body>
</html>