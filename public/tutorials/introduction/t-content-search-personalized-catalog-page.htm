<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <h1>Tutorial - Content and Search - Personalized Catalog Pages - <MadCap:variable name="General.ProductName" /></h1>
        <p class="info">This tutorial is also available on the Spryker Training web-site. For more information and hands-on exercises, visit the <a href="https://training.spryker.com/courses/developer-bootcamp">Spryker Training</a> web-site.</p>
        <h2>Challenge Description</h2>
        <p>The aim of this task is to build the first block of personalization for your shop. We are going to build a new CMS page and fill it with personalized products using the user's session ID. </p>
        <p>We will use the session ID just to show that products change when a new customer visits the page. </p>
        <p class="info">In a real case scenario, the session ID can be replaced and a score calculated from the customer's preferences and order history.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>1. Create the CMS Page</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <ol>
                    <li>
                        First, we will create the CMS page template. 
						<p>In <code>src/Pyz/Shared/Cms/Theme/default/templates</code>, add a new directory called <i>my-offers</i>.</p><p>Inside this folde, add a twig file called <i>my-offers.twig</i>.</p><p><pre><code class="language-PHP line-numbers">
{% extends template('page-layout-main') %}
 
{% define data = {
	title: _view.pageTitle | default('global.spryker.shop' | trans),
	metaTitle: _view.pageTitle | default('global.spryker.shop' | trans),
	metaDescription: _view.pageDescription | default(''),
	metaKeywords: _view.pageKeywords | default('')
} %}
 
{% block title %}
	&lt;!-- CMS_PLACEHOLDER : "title" --&gt;
	&lt;h3&gt;{{ spyCms('title') | raw }}&lt;/h3&gt;
{% endblock %}
 
{% block content %}
	&lt;!-- CMS_PLACEHOLDER : "content" --&gt;
	&lt;div class="box"&gt;
		{{ spyCms('content') | raw }}
	&lt;/div&gt;
{% endblock %}										
						</code></pre></p></li>
                    <li>Create a new CMS page from CMS tab in the back office. Use the twig template you have just added, and use the URL <i>/my-offers</i>. 
					</li>
                    <li>Click <b>Next</b> and fill the title and content of the page. 
					<p>Use any title and description you like to add.</p></li>
                    <li> Save the page, and publish it.</li>
                    <li>Now, we need to test the CMS page. Go to the <b>My Offers</b> page in your shop: <a href="http://www.de.suite.local/my-offers">http://www.de.suite.local/my-offers</a>.</li>
                </ol>
                <p>That is it! It is very simple to add a CMS page and publish it.</p>
                <p>Next, let's get the personalized products and add them to the page.</p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>2. Get the Personalized Products</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>To get the products, we will use <b>Elasticsearch</b>. To do so, we need to work with the <i>SearchClient</i> as it is the place to connect with <b>Elasticsearch</b>. </p>
                <p>So, mainly we will work with Yves to get the request from the shop, and the client to pass the request to <b>Elasticsearch</b> and get the response back.</p>
                <ol>
                    <li>First, create a new Yves module in <code>src/Pyz/Yves</code> and call it <b>PersonalizedProduct</b>.</li>
                    <li>Create a <code>PersonalizedProductControllerProvider</code> inside <code>src/Pyz/Yves/PersonalizedProduct/Plugin</code> and add the route to the personalized products inside it.
					<p><pre><code class="language-PHP line-numbers">
namespace Pyz\Yves\PersonalizedProduct\Plugin\Provider;
 
use Silex\Application;
use SprykerShop\Yves\ShopApplication\Plugin\Provider\AbstractYvesControllerProvider;
 
class PersonalizedProductControllerProvider extends AbstractYvesControllerProvider
{
	const PERSONALIZED_PRODUCT_INDEX = 'personalized-product-index';
 
		/**
		 * @param \Silex\Application $app
		 *
		 * @return void
		 */
		protected function defineControllers(Application $app)
		{
			$this-&gt;createGetController('/personalized-product/{limit}', static::PERSONALIZED_PRODUCT_INDEX, 'PersonalizedProduct', 'Index', 'index')
				-&gt;value('limit', 10)
				-&gt;assert('limit', '\d+');
		}
}
					</code></pre></p><div class="info">The <i>value()</i> method gives a default value in case the limit value is not passed from the URL.
							<p>The <i>assert()</i> method checks if the limit value is a positive integer.</p></div></li>
                    <li>Register the <code>PersonalizedProductControllerProvider</code> in the method <code>getControllerProviderStack()</code> inside YvesBootstrap.</li>
                    <li>Create an <i>IndexController</i> for the <b>PersonalizedProduct</b> module in <code>src/Pyz/Yves/PersonalizedProduct/Controller</code> and add an <i>indexAction()</i>. 
					<p>Then add the twig template for the controller and the action in <code>src/Pyz/Yves/PersonalizedProduct/Theme/default/views/index</code> and call it <i>index.twig</i>.</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Yves\PersonalizedProduct\Controller;
 
use Spryker\Yves\Kernel\Controller\AbstractController;
 
class IndexController extends AbstractController
{
	/**
	 * @param $limit
	 *
	 * @return array
	 */
	public function indexAction($limit)
	{
		return [];
	}
}								
</code></pre></p><p><pre><code class="language-PHP line-numbers">
{% extends template('page-blank') %}
 
{% block body %}
	{{ 'My Personalized Products' }}
{% endblock %}									
</code></pre></p></li>
                    <div class="info">For now, the Yves part is done. You can now go to <a href="http://www.de.suite.local/personalized-product/12">http://www.de.suite.local/personalized-product/12</a> and get the personalized products page.
					<p>Now try <a href="http://www.de.suite.local/personalized-product/not-positive-integer">http://www.de.suite.local/personalized-product/not-positive-integer</a>, this should result in an <code>404</code> error as the rout in not defined.</p><p>The next set of steps is for work on the client. By performing those, you will connect your module to Elasticsearch. First, you need a client for that in order to connect Yves to Elasticsearch.</p></div>
                    <li>Create the PersonalizedProduct's client directory in <b>src/Pyz/Client</b> and call it <i>PersonalizedProduct</i> and add the client class and interface.
					<p><pre><code class="language-PHP line-numbers">
namespace Pyz\Client\PersonalizedProduct;
 
interface PersonalizedProductClientInterface
{
	/**
	 * @param int $limit
	 *
	 * @return array
	 */
	public function getPersonalizedProducts($limit);
}						
						</code></pre></p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Client\PersonalizedProduct;
 
use Spryker\Client\Kernel\AbstractClient;
 
class PersonalizedProductClient extends AbstractClient implements PersonalizedProductClientInterface
{
	/**
	 * @param int $limit
	 *
	 * @return array
	 */
	public function getPersonalizedProducts($limit)
	{
	}
}									
									</code></pre></p></li>
                    <li>To get the products from Elasticsearch, we need to use the SearchClient. In the SearchClient there is the method <code>search()</code> that queries the search engine and takes a search query and an array of formatters as parameters. So, we need three main steps here: 
					<ul><li>create the query</li><li>get the formatters </li><li>get the SearchClient.</li></ul>Then we can hook things together. 
						<p>First, let's create the query. The query is basically a plugin implementing the QueryInterface. 
						<ol><li>Add the following directory structure inside the client's directory: Plugin/Elasticsearch/Query.</li><li>Then add the query plugin inside it and call it PersonalizedProductQueryPlugin:</li></ol></p><p><pre><code class="language-PHP line-numbers">								
namespace Pyz\Client\PersonalizedProduct\Plugin\Elasticsearch\Query;
 
use Elastica\Query;
use Elastica\Query\BoolQuery;
use Elastica\Query\FunctionScore;
use Elastica\Query\Match;
use Elastica\Query\MatchAll;
use Generated\Shared\Search\PageIndexMap;
use Spryker\Client\Search\Dependency\Plugin\QueryInterface;
use Spryker\Shared\ProductSearch\ProductSearchConfig;
 
class PersonalizedProductQueryPlugin implements QueryInterface
{
	/**
	 * @var int
	 */
	protected $limit;
 
	/**
	 * @param int $limit
	 */
	public function __construct($limit)
	{
		$this-&gt;limit = $limit;
	}
 
	/**
	 * @return \Elastica\Query
	 */
	public function getSearchQuery()
	{
		$boolQuery = (new BoolQuery())
			-&gt;addMust((new FunctionScore())
				-&gt;setQuery(new MatchAll())
				-&gt;addFunction('random_score', ['seed' =&gt; session_id()])
				-&gt;setScoreMode('sum'))
			-&gt;addMust((new Match())
				-&gt;setField(PageIndexMap::TYPE, ProductSearchConfig::RESOURCE_TYPE_PRODUCT_ABSTRACT));
 
		$query = (new Query())
			-&gt;setSource([PageIndexMap::SEARCH_RESULT_DATA])
			-&gt;setQuery($boolQuery)
			-&gt;setSize($this-&gt;limit);
 
		return $query;
	}
}								
									</code></pre></p><p class="info">As you notice, we have the limit passed in the constructor of the query plugin. Also, the seed value is the <code>session_id()</code> of the customer and it is used with the random score from Elasticsearch. Again, you can change these values according to your needs.</p></li>
                    <li>Both the formatters and the <b>SearchClient</b> are and external dependency to our <code>PersonalizedProductClient</code>, therefore we need to use the dependency provider to get them and inject them inside our client. Create the <code>PersonalizedProductDependencyProvider</code> in <code>src/Pyz/Client</code> and get both the formatters array and the <b>SearchClient</b>. 
					<p>The formatter that we need to use here is the <code>RawCatalogSearchResultFormatterPlugin</code>.</p><p>Your dependency provider will look like this:</p><p><pre><code class="language-PHP line-numbers">
namespace Pyz\Client\PersonalizedProduct;
 
use Spryker\Client\Catalog\Plugin\Elasticsearch\ResultFormatter\RawCatalogSearchResultFormatterPlugin;
use Spryker\Client\Kernel\AbstractDependencyProvider;
use Spryker\Client\Kernel\Container;
 
class PersonalizedProductDependencyProvider extends AbstractDependencyProvider
{
	const CLIENT_SEARCH = 'CLIENT_SEARCH';
	const CATALOG_SEARCH_RESULT_FORMATTER_PLUGINS = 'CATALOG_SEARCH_RESULT_FORMATTER_PLUGINS';
 
	/**
	 * @param \Spryker\Client\Kernel\Container $container
	 *
	 * @return \Spryker\Client\Kernel\Container
	 */
	public function provideServiceLayerDependencies(Container $container)
	{
		$container = $this-&gt;addSearchClient($container);
		$container = $this-&gt;addCatalogSearchResultFormatterPlugins($container);
 
		return $container;
	}
 
	/**
	 * @param \Spryker\Client\Kernel\Container $container
	 *
	 * @return \Spryker\Client\Kernel\Container
	 */
	protected function addSearchClient(Container $container)
	{
		$container[static::CLIENT_SEARCH] = function (Container $container) {
			return $container-&gt;getLocator()-&gt;search()-&gt;client();
		};
 
		return $container;
	}
 
	public function addCatalogSearchResultFormatterPlugins($container)
	{
		$container[static::CATALOG_SEARCH_RESULT_FORMATTER_PLUGINS] = function () {
			return [
				new RawCatalogSearchResultFormatterPlugin()
			];
		};
 
		return $container;
	}
}
</code></pre></p></li>
                    <li>To use the dependencies from the <code>PersonalizedProductDependencyProvider</code>, we need the factory. Create the <code>PersonalizedProductFactory</code> in <code>src/Pyz/Client</code>, then get the dependencies and create the <code>PersonalizedProductQueryPlugin</code> in order for them to be used from the client.
<p><pre><code class="language-PHP line-numbers">						
namespace Pyz\Client\PersonalizedProduct;
 
use Pyz\Client\PersonalizedProduct\Plugin\Elasticsearch\Query\PersonalizedProductQueryPlugin;
use Spryker\Client\Kernel\AbstractFactory;
 
class PersonalizedProductFactory extends AbstractFactory
{
	/**
	 * @param $limit
	 *
	 * @return PersonalizedProductQueryPlugin
	 */
	public function createPersonalizedProductsQueryPlugin($limit)
	{
		return new PersonalizedProductQueryPlugin($limit);
	}
 
	/**
	 * @throws \Spryker\Client\Kernel\Exception\Container\ContainerKeyNotFoundException
	 *
	 * @return array
	 */
	public function getSearchQueryFormatters()
	{
		return $this-&gt;getProvidedDependency(PersonalizedProductDependencyProvider::CATALOG_SEARCH_RESULT_FORMATTER_PLUGINS);
	}
 
	/**
	 * @throws \Spryker\Client\Kernel\Exception\Container\ContainerKeyNotFoundException
	 *
	 * @return \Spryker\Client\Search\SearchClientInterface
	 */
	public function getSearchClient()
	{
		return $this-&gt;getProvidedDependency(PersonalizedProductDependencyProvider::CLIENT_SEARCH);
	}
}
						</code></pre></p></li>
                    <li>The client now can get all the objects it needs to send the search query and to get the response back from Elasticsearch. 
					<p><pre><code class="language-PHP line-numbers">
/**
 * @param int $limit
 *
 * @throws \Spryker\Client\Kernel\Exception\Container\ContainerKeyNotFoundException
 *
 * @return array
 */
public function getPersonalizedProducts($limit)
{
	$searchQuery = $this
		-&gt;getFactory()
		-&gt;createPersonalizedProductsQueryPlugin($limit);
 
	$searchQueryFromatters = $this
		-&gt;getFactory()
		-&gt;getSearchQueryFormatters();
 
	$searchResult = $this-&gt;getFactory()
		-&gt;getSearchClient()
		-&gt;search(
			$searchQuery,
			$searchQueryFromatters
		);
 
	return $searchResult;
}					
									</code></pre></p></li>
                    <li>Finally, let's hook things together. The client is done, and now we only need to update the controller and its twig template so it calls the client and renders the results.
<p><pre><code class="language-PHP line-numbers">					
namespace Pyz\Yves\PersonalizedProduct\Controller;
 
use Spryker\Yves\Kernel\Controller\AbstractController;
 
class IndexController extends AbstractController
{
	/**
	 * @param $limit
	 *
	 * @throws \Spryker\Client\Kernel\Exception\Container\ContainerKeyNotFoundException
	 *
	 * @return \Spryker\Yves\Kernel\View\View
	 */
	public function indexAction($limit)
	{
		$searchResults = $this-&gt;getClient()-&gt;getPersonalizedProducts($limit);
 
		return $this-&gt;view(
			$searchResults,
			[],
			'@PersonalizedProduct/views/index/index.twig'
		);
	}
}					
</code></pre></p><p><pre><code class="language-PHP line-numbers">	

{% extends template('page-blank') %}
 
{% define data = {
	products: _view.products
 %}
 
{% block body %}
	&lt;div&gt;
		{% for product in data.products %}
			&lt;div&gt;
				{% include molecule('product-card') with {
					data: {
						name: product.abstract_name,
						abstractId: product.id_product_abstract,
						url: product.url,
						imageUrl: product.images.0.external_url_small,
						price: product.price,
						originalPrice: null
					}
				} only %}
			&lt;/div&gt;
		{% endfor %}
	&lt;/div&gt;
{% endblock %}												
</code></pre></p></li>
                </ol>
                <div class="info">That's it for getting the personalized products. 
				<p>To demonstrate having different personalized products for different customers. Go to <a href="http://www.de.suite.local/personalized-product/12">http://www.de.suite.local/personalized-product/12</a> and check out the products. Refresh the page, you should see the same products as you still have the same session ID.</p><p>Now, remove the Spryker cookie so the session ID is different and refresh the page, you should see different products. This different customers with different sessions IDs get different personalized products.</p></div>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>3. Put the personalized products in the CMS page</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody>
                <p>Let's put our personalized products inside our CMS page, the one we have created in the first step, so they get the same look and feel of the whole shop with extra content around them. </p>
                <p>To do so, we will use the <b>render()</b> method with the twig templates. </p>
                <p>The method takes a path for the route name as a parameter. What it does is that it creates a sub-request internally and calls the route with the provided name, then it renders the results inside another twig template. Open <i>my-offers.twig</i> and use the render method like this <code>{{ render(path('personalized-product-index', {'limit': 12})) }}</code>.</p>
                <p><pre><code class="language-PHP line-numbers">
{% extends template('page-layout-main') %}
 
{% define data = {
	title: _view.pageTitle | default('global.spryker.shop' | trans),
	metaTitle: _view.pageTitle | default('global.spryker.shop' | trans),
	metaDescription: _view.pageDescription | default(''),
	metaKeywords: _view.pageKeywords | default('')
} %}
 
{% block title %}
	&lt;!-- CMS_PLACEHOLDER : "title" --&gt;
	&lt;h3&gt;{{ spyCms('title') | raw }}&lt;/h3&gt;
{% endblock %}
 
{% block content %}
	&lt;!-- CMS_PLACEHOLDER : "content" --&gt;
	&lt;div class="box"&gt;
		{{ spyCms('content') | raw }}
	&lt;/div&gt;
	&lt;div class="box"&gt;
		{{ render(path('personalized-product-index', {'limit': 12})) }}
	&lt;/div&gt;
{% endblock %}
				</code></pre>
                </p>
                <p>Done! To check the results, go to <a href="http://www.de.suite.local/my-offers">http://www.de.suite.local/my-offers</a>. </p>
                <p>Remove the Spryker cookie and refresh again to see different personalized products.</p>
                <p>&#160;</p>
                <p>&#160;</p>
                <p><i>Last review date: Jul 03, 2018</i> <i MadCap:conditions="General.Hidden Comment">by Hussam Hebbo, Anastasija Datsun</i></p>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
    </body>
</html>