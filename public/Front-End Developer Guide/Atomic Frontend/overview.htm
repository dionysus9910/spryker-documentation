<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:conditions="Spryker.B2C,Spryker.B2B,Spryker.ShopSuite">
    <head><title>Atomic Frontend | Spryker</title>
        <link href="../../Resources/TableStyles/VerticalTable.css" rel="stylesheet" MadCap:stylesheetType="table" />
        <meta name="description" content="Spryker Frontend implements the atomic design design. Read about the basic principles of Spryker UI implementation. Spryker UI is based on the component model, atomic design and BEM methodology concepts. " />
    </head>
    <body>
        <h1>Atomic Frontend <img src="../../Resources/shoptype/MasterSuite.png" /> <img src="../../Resources/shoptype/B2B_Shop.png" /> <img src="../../Resources/shoptype/B2C_Shop.png"> </img> </h1>
        <p><strong>In this page</strong>:</p>
        <p>To provide each customer with exactly the features they require, Spryker Commerce OS has been
    split into modules. Each customer can have a unique set of modules, and even module versions,
    specific to their business requirements. This fact combined with the possibility for customers
    to develop functionality on their own poses a big challenge for frontend developers. To ease
    the task, Spryker Frontend implements a design methodology called <strong>atomic design</strong>.
    Because of this, the UI layer of Spryker is called <em>Atomic Frontend</em>.</p>
        <p>The following document describes the basic principles of Spryker UI implementation and
        explains how to perform the tasks required to design Spryker UI.
        </p>
        <h1>Basic Concepts</h1>
        <p>Spryker UI is based upon the following concepts:</p>
        <h2>Component Model</h2>
        <p><em>Atomic design</em> is an approach that allows you to develop user interface as a set of
    self-contained, independent and reusable functional units, or <strong>components</strong>.
    Within the approach, frontend design can be viewed as a process of bonding components together
    to fulfill
    a certain functional goal. By combination of various components, you can create powerful and
    flexible UI applications of any level of complexity.</p>
        <p>The main idea of a component is that it should contain and carry in itself all the behavior and
    visual assets necessary to use it on a web page. Also, components
        should not manipulate DOM directly, they are always declarative.
    This makes integrating different components seamlessly and effortlessly regardless of where and
    how they are used.</p>
        <p class="tip">For more details on the component module implemented by Spryker, and detailed
            specifications, see <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web
                Components</a>.</p>
        <p>The component model provides the following benefits:
        </p>
        <ul>
            <li>decoupling of backend from frontend,
            </li>
            <li>support for Spryker modularity with a UI component library,
            </li>
            <li>possibility to define clear contracts between backend and frontend in terms of data,
            </li>
            <li>better atomicity and encapsulation of frontend,
            </li>
            <li>improved UI reusability,
            </li>
            <li>better code quality.
            </li>
        </ul>
        <p>The following peculiarities are characteristic of Spryker usage of Web Components:</p>
        <ul>
            <li><em>Shadow DOM</em> is not used. DOM implementation is always explicit.</li>
            <li>Web Components are used only for behavior management. No client side rendering or logic is
        implemented in the frontend.</li>
            <li>HTML rendering is done by Twig.</li>
        </ul>
        <h2>Atomic Design</h2>
        <p>Based on their structure and use, all components are divided into the following logical and
    functional categories:</p>
        <ul>
            <li><strong>
            atom
        </strong>
         - These are the
            smallest, most basic building blocks of UI design. Typical examples of atoms are
            labels, input fields or buttons. Usually, atoms are very abstract in their essence and
            limited to a single functionality that can be included in many pages. They are not very
            useful by themselves. Being the smallest building block of atomic design, atoms cannot
            include other components.
    </li>
            <li><strong>molecules</strong> - Molecules typically include
            two or more atoms or other molecules bonded together to serve a single purpose. These
        structures are already complex enough to have their own properties, however they should not
        be overcomplicated and built for wide reuse.</li>
            <li><strong>organisms</strong> - Such components are rather specific and already provide
        sufficient context for the molecules and atoms they are composed of. Usually, organisms do
        not form a certain page, but they are rather specific as to what they do and what is their
        function. Typical
            examples of organisms can include a header, a footer, the sidebar etc. Such
        components are already complex enough to be used directly on a page.</li>
            <li><strong>widgets</strong> - This
            is a special type of components that can be used to inject information from an external
            data source that might be unavailable  On the backend side, a widget must contain
            logic to access the data source and verify whether it is available. On the frontend
            side, a widget must provide means to show or hide information in such a way as not to
            break the functionality of the entire shop if the data source is not available. A
            typical use case for widgets is to show information from Spryker modules that can be
            missing in a specific customer implementation. For example, if the
        <em>
            Discounts
        </em>
         module is not used
            in a project, this should not break the calculation of the overall price, for which
            reason discounts information is injected as a widget. Generally, it is recommended to
            limit the use of widgets as much as possible in your projects.
    </li>
            <li>
                <p><strong>templates</strong> - Templates can be viewed as combinations of components
            composed according to a specific graphic layout. They are used to define a visual
            schema for a set of pages. Typically, pages with a common template have the same
            structure and share most of content with the exception of a small portion of
            page-specific or widget-specific information that changes from page to page. Thus,
            a template serves as a backbone that defines a set of shared components and the
            overall layout. Examples of templates are the main site layout or the checkout layout.</p>
            </li>
            <li>
                <p><strong>views</strong> - This
                is the the highest point in the frontend hierarchy. A
            view is a template filled with specific content for use in a specific case. It
            represents a specific page or widget. Views are the only components that can be called
            by the backend directly which means that they also serve as a connection point
            between backend and frontend. On the backend side, views are always connected to
            controllers.
        </p>
            </li>
        </ul>
        <p>For more details on the component model that inspired Spryker frontend,
    see <a href="http://bradfrost.com/blog/post/atomic-web-design/">Atomic Design</a>.</p>
        <h2>BEM Methodology</h2>
        <p>
    The styling of Spryker
        Shop UI components is based upon BEM methodology. It is applied on the
    <strong>
        SASS
    </strong>
     layer of the shop
        UI. For a detailed specification and recommended practices, see
    <a href="https://en.bem.info/methodology/css/">
        CSS with BEM
    </a>
    . For BEM conventions,
        see section <strong>Naming Conventions</strong>.
</p>
        <h2>Technology stack</h2>
        <p>The following technologies are used to enable Spryker Atomic Frontend:
        </p>
        <ul>
            <li><strong>Twig</strong> <br />Twig is the template engine behind the frontend. It allows easy
        integration of frontend with Spryker backend, which is PHP-based, and also deeply
        integrates with Symfony that is used as Spryker framework. For details, see <a href="https://twig.symfony.com/">here</a>.
        Spryker uses <strong>version 1</strong> of Twig,</li>
            <li><strong>SASS</strong> <br />SASS is a very powerful superset of CSS that provides the
        benefit of using variables, mixins, functions, and conditions in CSS. <a href="https://sass-lang.com/">More
            information</a>.</li>
            <li><strong>ES6 Javascript</strong> <br />The ES6 implementation of Javascript benefits
        from advanced features, such as class, array and object methods. It allows to have cleaner
        and more organized code, while simplifying it to a big degree. Detailed information on this
        implementation of Javascript can be found <a href="http://exploringjs.com/es6/">here</a>.</li>
            <li>
                <p><strong>Typescript</strong> <br />Typescript is a superset of
            Javascript that allows to reinforce the object-oriented approach in programming
            behaviors. It is used to make Javascript strictly typed, increasing readability and
            maintainability, reducing the likelihood of type-related mistakes and enforces strong
            contracts in terms of data. Detailed information can be found <a href="https://www.typescriptlang.org/">here</a>.</p>
                <p class="tip">If necessary, you can develop in pure Javascript. For details, see //How to Customize Spryker Frontend TODO:.
                </p>
                <p>
                    <br />
                </p>
            </li>
            <li><strong>Web Components</strong> <br />The Web Component standard was chosen as a reliable,
        high-performance and consistent approach to creating UI components. The
        main
        benefit of this approach is that any user interface created with the help of Web Components
        will be non-changeable across platforms and browsers. Also, it reduces the number of
        project dependencies required. Basically, everything that is needed to enable Web
        Components is a set of polyfills. <a href="https://www.webcomponents.org/">More details</a>.</li>
            <li><strong>
            Webpack
        </strong>
                <br />The frontend is based on
                    <strong><a href="https://webpack.js.org/">Webpack</a></strong>.
                    This
                        bundler is responsible for building
                            and compiling project assets.
                    It provides the benefit allows
                    using <em>Typescript</em> for manipulating behavior, <em>SASS</em> for designing styles,
                        and
                        <em>
                            Twig
                            
                        </em>
                        as
                            the template language, compiling them to native HTML,
                        Javascript and CSS that can be rendered by the browser. 
                    In
                        addition to that, it
                            provides <em>
                            Polyfills
                        </em>
                         to
                            enable support for older web browsers. It is
                        extremely flexible and totally configurable to the project needs.
                    
            </li>
        </ul>
        <h1>Implementation Details</h1>
        <p>
    Spryker
    Shop is a modular system composed of several independent modules. The atomic frontend follows
    the general modular approach:
</p>
        <p><strong>ShopUi</strong>
        </p>
        <p><em>ShopUi</em> is the main module that implements the core part of Spryker Shop frontend. It
    contains basic and shared code, such as global styles, main application bootstrap for
    Javascript, Twig models etc. Also, it implements all general purpose components that are not
    related to a specific feature and can be used in every other module. It is the main application
    of the atomic frontend.</p>
        <p><strong>Feature Modules</strong>
        </p>
        <p>Besides the main application module, there are several other modules that define components,
    templates and views. Such modules are dedicated to a specific features, or distinctive parts of
    it, and contain only the assets that can be used within the framework of those features. The
    design of the components contained in such a module is very specific to the feature it
    implements and can hardly be used out of its context. Examples of such modules are <em>CartPage</em>
    or <em>ProductImageWidget</em>.</p>
        <p>Although each feature module is a self-contained entity, there are some exceptions. Sometimes,
    it might happen that two or more modules are dependent on one another (this does not include
    the <em>ShopUi</em> module, on which all frontend modules are dependent). In this case, it is
    allowed to use components across modules. If you resort to such methodology, be sure to
    explicitly declare the module dependency in the <em>composer.json</em> files of the respective
    modules. As a general best practice, this behavior is not recommended unless really needed.</p>
        <p>The naming and other conventions, as well as folder structure applied in the <em>ShopUi</em> module
    are also valid and applied in each and every module that implements user interface. This
    approach must be strictly followed to standardize the folder structure and ensure that Webpack
    can crawl into the all Spryker Shop folders and load every component. The same is also
    necessary for Twig managed by PHP.</p>
        <h2>
    Folder Structure
</h2>
        <p>Spryker frontend implementation is split into several folders depending on their usage and
    function:</p>
        <table class="TableStyle-VerticalTable" style="width: 53.4247%;mc-table-style: url('../../Resources/TableStyles/VerticalTable.css');" cellspacing="0">
            <colgroup>
                <col style="width: 50.616%;" />
                <col style="width: 49.384%;" />
            </colgroup>
            <tbody>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body1"><strong>frontend</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body1">Contains Webpack implementation for Spryker frontend.</td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body2"><strong>public</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body2">Folder where Webpack places compiled assets, such as Javascript files, CSS styles,
                images, fonts etc.</td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body1"><strong>vendor/spryker-shop </strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body1">
                Contains
                    the main application (ShopUi) as shipped by Spryker.
            </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td class="TableStyle-VerticalTable-BodyB-Column1-Body2"><strong>src/Pyz/Yves </strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyA-Column2-Body2">
                In this
                    folder, you can place your own implementation of the Shop Suite and its modules
            </td>
                </tr>
            </tbody>
        </table>
        <h3>Shop UI</h3>
        <p>The application is implemented by module <strong>ShopUI</strong>. It is located in the following
    folders:</p>
        <table class="TableStyle-VerticalTable" style="width: 53.3151%;mc-table-style: url('../../Resources/TableStyles/VerticalTable.css');" cellspacing="0">
            <colgroup>
                <col style="width: 50.9259%;" />
                <col style="width: 49.0741%;" />
            </colgroup>
            <tbody>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body1"><strong>vendor/spryker-shop/shop-ui</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body1">Contains the default shop implementation as shipped by Spryker.</td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td class="TableStyle-VerticalTable-BodyB-Column1-Body2"><strong>src/Pyz/Yves/ShopUi</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyA-Column2-Body2">This folder can be used to override certain parts of the default implementation, or
                the shop UI implementation as a whole, on the project level.</td>
                </tr>
            </tbody>
        </table>
        <p>
    Components, styles and
        templates will be loaded from the following folders:
</p>
        <ul>
            <li><strong>vendor/spryker-shop/shop-ui/src/SprykerShop/Yves/ShopUi/Theme/default</strong> - on
        the global level;</li>
            <li><strong>src/Pyz/Yves/ShopUi/Theme/default</strong> - on the project level.</li>
        </ul>
        <p class="info">Note that project-level implementation has higher priority and loaded after the global
            implementation.</p>
        <p>
    The structure of the
        <strong>default</strong> folder is as follows (both on the global and project level):
</p>
        <table class="TableStyle-VerticalTable" style="width: 53.4247%;mc-table-style: url('../../Resources/TableStyles/VerticalTable.css');" cellspacing="0">
            <colgroup>
                <col style="width: 50.7187%;" />
                <col style="width: 49.2813%;" />
            </colgroup>
            <tbody>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body1">
                        <p><strong>components</strong>
                            <br /><strong>   /atoms</strong>
                            <br /><strong> 
                         /molecules</strong>
                            <br /><strong>   /organisms</strong>
                        </p>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body1">Folders for low-level components. Each component must be placed in its own folder.</td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td colspan="1" class="TableStyle-VerticalTable-BodyE-Column1-Body2"><strong>models</strong>
                    </td>
                    <td colspan="1" class="TableStyle-VerticalTable-BodyD-Column2-Body2">
                Contains
                    the Twig models used in the frontend.
            </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td colspan="1" class="TableStyle-VerticalTable-BodyE-Column1-Body1"><strong>resources</strong>
                    </td>
                    <td colspan="1" class="TableStyle-VerticalTable-BodyD-Column2-Body1">
                Contains
                    application resources.
            </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body2"><strong>styles</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body2">
                        <p>
                    
                        Holds
                            all 
                    
                    
                        SCSS-related
                            assets, such as 
                    utility classes, variables, reset for browser
                    styles, grids and so on.
                </p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td colspan="1" class="TableStyle-VerticalTable-BodyE-Column1-Body1"><strong>templates</strong>
                    </td>
                    <td colspan="1" class="TableStyle-VerticalTable-BodyD-Column2-Body1">Folder for Twig files with templates. Each template must be placed in
                its own folder.</td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td colspan="1" class="TableStyle-VerticalTable-BodyE-Column1-Body2"><strong>views</strong>
                    </td>
                    <td colspan="1" class="TableStyle-VerticalTable-BodyD-Column2-Body2">Folder for Twig files with views. Each
                    view must be placed in its own folder.
            </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td colspan="1" class="TableStyle-VerticalTable-BodyB-Column1-Body1">
                        <p><strong>app.ts</strong>
                            <br /><strong>es6-polyfill.ts</strong>
                            <br /><strong>vendor.ts</strong>
                        </p>
                    </td>
                    <td colspan="1" class="TableStyle-VerticalTable-BodyA-Column2-Body1">Typescript entry points.</td>
                </tr>
            </tbody>
        </table>
        <h3>Feature Components</h3>
        <p>The feature components are located in folder <strong>vendor/spryker-shop</strong> alongside
    the <em>ShopUi</em> module. Regardless of their function and use, every module that has UI
    on its own contains folder <strong><em>ModuleName</em>/Theme/default</strong> that
    contains the UI implementation for the module. The folder structure is the same as that of
    the <em>ShopUi</em> application.</p>
        <h2>Main Application (Shop UI)</h2>
        <h3>Application Bootstrap</h3>
        <p>When you build the shop application, the builder (<em>Webpack</em>) will find all entry
    points of all components. Entrypoints are the files that <em>Webpack</em> uses to create the
    output assets.</p>
        <p>There are 3 entrypoints that will be loaded in the DOM in the following order:</p>
        <ul>
            <li><strong>es6-polyfill:</strong>
                <br /><em>src/Pyz/Yves/ShopUi/Theme/default/es-polyfill.ts</em>
                <br />Provides
        ES6 polyfills used for compatibility with older browsers.<br /><br /></li>
            <li><strong>vendor:<br /></strong><em>src/Pyz/Yves/ShopUi/Theme/default/vendor.ts</em>
                <br />Contains
        all external dependencies required for your project.<br /><br /></li>
            <li><strong>app<br /></strong><em>src/Pyz/Yves/ShopUi/Theme/default/app.ts</em>
                <br />Contains
        the initialization logic for the project and the bootstrap code for the shop application.<br /><br /><em>
            src/Pyz/Yves/ShopUi/Theme/default/styles/basic.scss
        </em><br />        Contains basic
            styles.<br /><br /><em>
            Components
        </em><br />        When basic styles
            are loaded, behavior logic and styles of every component is loaded. This ensures that
            styles of each component override the basic styles.<br /><br /><em>
            src/Pyz/Yves/ShopUi/Theme/default/styles/util.scss
        </em><br />Contains util styles for the project. It is loaded at the very end as the styles
        defined in it should must override all styles, even the styles defined in components.
    </li>
        </ul>
        <h3>Webpack</h3>
        <p>The core Spryker frontend functionality is provided by
        <strong>Webpack</strong>. It serves as the main basis for the shop application
    and used to compile Typescript code and SASS into Javascript and CSS. In addition to that,
    Webpack collects static assets, such as images and fonts. </p>
        <p>Out of the box, the Webpack implementation provided by Spryker is sufficient to satisfy the
    needs of supporting a shop with the help of a Spryker shop application. However, if necessary,
    you can configure it the way you need.</p>
        <p>The Webpack implementation is located in the <strong>frontend</strong> folder and has the
    following structure:</p>
        <table class="TableStyle-VerticalTable" style="width: 53.5342%;mc-table-style: url('../../Resources/TableStyles/VerticalTable.css');" cellspacing="0">
            <colgroup>
                <col style="width: 50.0%;" />
                <col style="width: 50.0%;" />
            </colgroup>
            <tbody>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body1">
                        <p><strong>settings.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body1">
                        <p>Sets the main project settings</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body2">
                        <p><strong>build.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body2">
                        <p>Webpack loader. This file is called by <strong>npm</strong> when running <em>npm
                        run yves</em>.</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body1">
                        <p><strong>libs/alias.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body1">
                        <p>Takes the <em>paths</em> property defined in the <em>tsconfig.json</em> file and
                    transforms them into Webpack aliases. Using this file ensures that an alias
                    defined in Typescript is available not only everywhere in Typescript, but also
                    in SASS.</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body2">
                        <p><strong>libs/compiler.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body2">
                        <p>Calls Webpack as a compiler and prints out a human-readable output of the build
                    process</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body1">
                        <p><strong>libs/finder.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body1">
                        <p>Finder is a set of functions needed to locate the assets for the frontend. This
                    is necessary because of Spryker architecture. Spryker, being a modular
                    application, can contain various modules. Some of them have a frontend
                    implementation, and some do not. The finder locates all frontend assets in all
                    modules and passes them to Webpack to compile. For this purpose, a set of
                    <strong>glob</strong> operations on the file system are used.</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body2">
                        <p><strong>configs/development.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body2">
                        <p>Webpack configuration for development environment.</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body1">
                        <p><strong>configs/development-watch.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body1">
                        <p>Webpack configuration for development environment that also provides watchers.</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td width="467" class="TableStyle-VerticalTable-BodyE-Column1-Body2">
                        <p><strong>configs/production.js</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyD-Column2-Body2">
                        <p>Webpack configuration for production environment.</p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td width="467" class="TableStyle-VerticalTable-BodyB-Column1-Body1">
                        <p><strong>assets/</strong>
                        </p>
                    </td>
                    <td width="467" class="TableStyle-VerticalTable-BodyA-Column2-Body1">
                        <p>Contains static assets (images and fonts) used in the project. This the place to
                    put static files used in your project. They will be copied to the <strong>public</strong>
                    folder automatically.</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>The resulting compiled data is placed in the <strong>public</strong> folder of your Spryker code
    installation.</p>
        <h3>SASS Layer</h3>
        <p>The SASS layer is responsible for styling the frontend UI. It contains the styles, mixins,
    functions, variables etc necessary to provide visual styling for Shop UI components.</p>
        <p>Depending on their location and function, SASS styles are divided into <strong>4</strong> types:</p>
        <ul>
            <li><strong>Basic</strong> Styles - comprise the most basic styles used everywhere.
        Typical examples include HTML reset, grid layouts or animations etc. Such styles are loaded
        by Webpack at the
            very beginning of application bootstrapping and can be
        easily overridden at the component level. They are located in the following files:<br /><em>vendor/spryker-shop/shop-ui/src/SprykerShop/Yves/ShopUi/Theme/default/styles/basic.scss</em>
        - on the global level;<br /><em>src/Pyz/Yves/ShopUi/Theme/default/styles/basic.scss</em> -
        on the project level.<br /><br />You can find default basic styles in the following
        folder: <em>vendor/spryker-shop/shop-ui/src/SprykerShop/Yves/ShopUi/Theme/default/styles/basics</em>.<br /><br /></li>
            <li><strong>Component</strong> Styles - are styles of each specific component. These styles are
        defined for each component separately in its own <em>SCSS </em>file. Such styles
        are loaded after the <em>basic styles</em>, thus they can override them. Depending on
        where a component is located, the visibility of its styles is different. Mixins that define
        styles of core components located in the <em>vendor</em> folder are visible everywhere
        and shared across the whole application. Mixins of project components located in the <em>src/Pyz</em>
        folder are not shared and visible only within the component itself by default.<br /><br /></li>
            <li><strong>Util</strong> Styles - this group includes utility styles for the Shop UI, like,
        for example, the spacing system, text helpers, <em>float-right</em>, <em>float-left </em>or <em>is-hidden</em>
        implementations. Such styles are typically used to modify or even override the default
        layout or behavior of the components whenever necessary. For example, <em>is-hidden</em>
        implementations can be used to hide elements that are usually visible. For this reason,
        such styles should not be overridden by any other styles. Because of this, they are
        loaded at the very
            end of application bootstrap, when all other styles are
        loaded. Utility styles are located in the following files:<br /><em>vendor/spryker-shop/shop-ui/src/SprykerShop/Yves/ShopUi/Theme/default/styles/util.scss</em>
        - on the global level;<br /><em>src/Pyz/Yves/ShopUi/Theme/default/styles/util.scss</em> -
        on the project level.<br /><br />You can find default util styles in the following
        folder: <em>vendor/spryker-shop/shop-ui/src/SprykerShop/Yves/ShopUi/Theme/default/styles/util</em>.<br /><br /></li>
            <li><strong>
            Shared
        </strong> Styles - is the place to put global SASS variables, functions and mixins. Such
        style files are loaded automatically before loading each style file, and thus available in
        any style file in the project.<br /><br />The global implementation is located in the
        following file: <em>vendor/spryker-shop/shop-ui/src/SprykerShop/Yves/ShopUi/Theme/default/styles/shared.scss</em>.
        <br /><br />You can provide your global SASS components in the following file: <em><em>src/Pyz/Yves/ShopUi/Theme/default/style/shared.scss.<br /><br /></em></em>By
        default, global styles are imported from the <em>settings</em> and <em>helpers</em>
        folders. Any imports can be overridden directly in your <em>shared.scss</em> file. The
        folders contain the following:<br /><ul><li><strong>settings</strong> - contains only variables, organized by topic,</li><li><strong>helpers</strong> - contains all global functions and mixins used in
                the system.</li></ul></li>
        </ul>
        <h2>Naming Conventions</h2>
        <p>The following naming conventions must be observed in Spryker Shop:</p>
        <p><strong>Files and Folders</strong>:</p>
        <p>Atomic frontend uses <strong>kebab-case</strong> as naming convention for every file/folder name
    within the <em>default</em> folder;</p>
        <p><strong>Variables and Functions:</strong>
        </p>
        <ul>
            <li><strong>Twig</strong>: everything related to atomic frontend follows <strong>camelCase</strong>;</li>
            <li><strong>SASS:</strong> follows <strong>kebab-case</strong> and implements BEM
        methodology with the following syntax:<br /><ul><li>block: <em>.component-name</em></li><li>element: <em>.component-name__element</em></li><li>modifier: <em>.component-name--modifier</em> or <em>.component-name__element--modifier</em></li><li><strong>Note: </strong>as block modfiers are the only parameters we can use to
                customize a component when using it (<strong>include</strong> or <strong>embed</strong>),
                sometimes, you will find open violations of BEM in Spryker code. In particular,
                some block modifiers might be in cascade with elements in order to customize them.</li></ul></li>
            <li><strong>Typescript:</strong> follows <strong>camelCase</strong></li>
        </ul>
        <h2>Main Templates</h2>
        <p>Templates are <strong>.twig</strong> files containing a structure of a page or widget. It
    defines how a component is visually organised and arranged in terms of spacing and positions.</p>
        <p>The main templates in <em>ShopUi</em> are:</p>
        <ul>
            <li><strong>page-blank </strong>- defines a blank page. it does not contain any html in
        the <em>&lt;body&gt; </em>tag.<br />This template defines all basic assets for the
        frontend, such as the <em>&lt;head&gt;</em> content (meta info, styles, high priority
        scripts and page title), as well as the bottom part of the <em>&lt;body&gt;</em> content
        (vendor and application scripts).<br /><br /></li>
            <li><strong>page-layout-main</strong>: extends the <em>page-blank</em> template and defines the
        main layout for every single page in Spryker Suite.<br />This template contains the header,
        footer, sidebars etc, but soes not predefine the content of the page. This part is left
        blank to be defined by specific views.</li>
        </ul>
        <h2>Components</h2>
        <p>Every component is a self-contained entity that implements a
        certain functional purpose. It does not have parts that are executed in other components,
        nor it executes parts of code for them. However, a part of a component is executed on the
        server side (<em>Twig</em>), and the other part is run on the client side (<em>SCSS</em>
        and <em>Typescript</em>). For this reason, data required for a component should be
        retrieved via <em>Twig</em>, and then rendered into HTML code. As the data source, it is
        possible to use controller code or output of another component.
        </p>
        <p>The following conventions are applied to components:</p>
        <ul>
            <li>
                <p>every component, template or view is always contained in a folder with the same name;</p>
            </li>
            <li><em>
            atoms
        </em>
        ,
        <em>
            molecules
        </em>
         and
        <em>
            organisms
        </em>
         are always placed
            in folder <strong>
            components
        </strong>
         of the module they
            belong to;
    </li>
            <li>
                <p><em>templates</em> are always contained in folder <strong>templates</strong>;</p>
            </li>
            <li>
                <p>views are always contained in folder called <strong>views</strong>;</p>
            </li>
            <li>every component extends a model defined in <em>vendor/spryker-shop/shop-ui/src/SprykerShop/Yves/ShopUi/Theme/default/models/component.twig</em>.</li>
        </ul>
        <h3>Component Loading</h3>
        <p>
    For a component to be
        used by the shop application, it needs to be compiled by Webpack and provide a function to
        register it in the DOM. Thus, when DOM is loaded, the application checks which of the
        registered components are present there and mounts only those that are available at <em>
            DomContentLoaded
        </em>
        . For each
            component that is being mounted, Webpack calls the chunk related to a component and
            loads the code and assets. As soon as all components have finished mounting, the
            application calls the <em>
            app.ready
        </em>
         event indicating
            that each component has finished loading and ready to use.
    </p>
        <p>
    Mounting of components
        is asynchronous, which means that several components can be loaded at the same time,
        reducing the overall load time.
</p>
        <h3>Component Structure</h3>
        <p>A typical component folder consists of the following files:</p>
        <table class="TableStyle-VerticalTable" style="width: 53.589%;mc-table-style: url('../../Resources/TableStyles/VerticalTable.css');" cellspacing="0">
            <colgroup>
                <col style="width: 50.5629%;" />
                <col style="width: 49.4371%;" />
            </colgroup>
            <tbody>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body1"><strong>index.ts</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body1">Specifies the component entry point for Webpack. This file is necessary to locate
                the component styles
                    and Typescript code.</td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body2"><strong>component-name.ts</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body2">Specifies the behavior for the component in Typescript.</td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td class="TableStyle-VerticalTable-BodyE-Column1-Body1"><strong>component-name.scss</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyD-Column2-Body1">
                        <p>Contains the SCSS style for the component, wrapped into a mixin.</p>
                        <p><em><strong>Note:</strong> If a component contains the style.scss file, this
                        file only declares a mixin.</em>
                        </p>
                    </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body2">
                    <td colspan="1" class="TableStyle-VerticalTable-BodyE-Column1-Body2"><strong>style.scss</strong>
                    </td>
                    <td colspan="1" class="TableStyle-VerticalTable-BodyD-Column2-Body2">
                Imports the
                    style when <em>
                    component-name.scss
                </em>
                 contains
                    only mixin declaration.
            </td>
                </tr>
                <tr class="TableStyle-VerticalTable-Body-Body1">
                    <td class="TableStyle-VerticalTable-BodyB-Column1-Body1"><strong>component-name.twig</strong>
                    </td>
                    <td class="TableStyle-VerticalTable-BodyA-Column2-Body1">Defines a template for the component layout.</td>
                </tr>
            </tbody>
        </table>
        <p>The above structure contains a fully featured component, with styles and Typescript that defines
    the component behavior. Depending on what you are
        trying to achieve, you can have a component that includes both styles and behavior, or any
        of these separately. In addition to this, you can even create a component that has neither
        styles, nor behavior. In the latter case, the component will contain a template only
        consisting of a <strong>.twig</strong> file.</p>
        <p><em>Views</em> and <em>templates</em> always consist of
        a <strong>.twig</strong> file only.
        </p>
        <h3>Twig</h3>
        <p>When defining a component template with Twig, you need to use the following default entities:</p>
        <ul>
            <li>
                <p><strong>config</strong>
                    variable: specifies
                    the following base information about a component:<br /><em>Example:</em></p><pre><code class="language-Twig line-numbers">
% define config = {
    name: 'new-component-counter',
    tag: 'new-component-counter'
} %}
            </code></pre>
                <p><em>
                Attributes:
            </em>
                </p>
            </li>
            <ul>
                <li><strong>name</strong>: component name <em>(required)</em><br />Specifies the
                component name. This name is also used as the main class name for the component,
                therefore the HTML element and modifiers will have this name as the base.
                </li>
                <li><em><strong>jsName</strong>:</em> Javascript name of the component <em>
                    (optional)
                </em><br />By convention, whenever Javascript behavior is added to a
                component, the DOM addressing for elements should be performed using dedicated
                classnames starting with the <em>
                    -js
                </em> prefix. This prevents confusion in who-does-what: a classname starting with
                <em>js-</em> will have no style attached to it, but only Javascript behaviour.
                On the other hand, any classname that does <em>not </em>start with <em>js-</em>
                will be pure style.<br />If <em>jsName</em> is not defined
                explicitly, it will be created automatically by prefing <em>js-</em> to the
                component name.
                </li>
                <li><strong>tag</strong>: specifies the HTML tag name for the component <em>(optional)</em><br />Every
                component is defined in the DOM as an HTML class with its dedicated tag name<em>.
                </em>Therefore a tag name must be specified. You can use either a
                standard HTML5 tag name (e.g. <strong>p</strong> or <strong>td</strong>)
                or have a
                    custom element tag name in order to attach Javascript behavior.
                In case you want to create a component with custom behavior defined in Javascript,
                Web Component specification, you <strong>must</strong>
                specify a custom tag name.<br />If tag name is not specified, <strong>div</strong>
                is used by default.
                </li>
            </ul>
            <li>
                <p><strong>data</strong> variable: defines the data
                contract for the component.<br />This
                        variable is used the data contract for the component. The
                    contract consists of the attributes required for the component to function
                    properly. The attributes provided by this variable can be either <strong style="text-align: left;">required</strong> or <strong style="text-align: left;">optional</strong>. <em style="text-align: left;">Required</em> attributes
                    must always be defined whenever a component is used, while <em style="text-align: left;">optional </em>ones
                    can be left undefined. Nevertheless, by convention, attributes cannot have
                    their value undefined. For this reason, if you define an optional attribute in
                    your contract, you must set a default value for it. The default value will be
                    used if an attribute value is not set explicitly or via context.<br />Whenever
                possible, use primitive types (e. g. strings, numbers etc). Avoid complex objects
                as a change in the object might lead to a broken component outside the contract
                itself.<br /><em>Example:</em></p><pre><code class="language-Twig line-numbers">

% define data = {
    name: required,
    description: 'no description'
} %}
            </code></pre>
                <p>
                    <br />
                </p>
            </li>
            <li>
                <p><strong>attributes</strong> variable: defines
                HTML5 attributes for the component<br />If
                    not <strong>null</strong> or <strong>false</strong>, the specified
                    attributes will be rendered in the component's HTML5 tag. The same as <strong style="text-align: left;">data</strong> attributes, an
                        HTML5 attribute can be <strong>required<em> </em></strong>or
            <strong>optional</strong> with a default value.<br /><em>Example:<br /></em></p><pre><code class="language-Twig line-numbers">

% define attributes = {
    'element-selector': required
} %}
            </code></pre>
            </li>
            <li><strong>class</strong> variable: defines external class names that a component might
            receive from the context.
            </li>
            <li><strong>modifiers</strong> array: defines a list of modifiers received from the
            context that can be applied to the main block.
            </li>
            <li><strong>embed</strong> variable: defines a list of variables that a component might
            receive from the context, specifically to be used for <em>Twig</em> embedding.
            </li>
            <li><strong>macros</strong>
            </li>
            <ul>
                <li><strong>renderClass</strong>: renders the classnames for the component. According
                to BEM specifications, the following is rendered:
                    <ul><li><em>name</em> (as defined in the <em>config</em> variable),
                        </li><li><em>modifiers</em> (if passed via the <em>modifiers</em> array)
                        </li><li><em>external class names</em> (if passed via the <em>class</em>
                            varible).
                        </li></ul></li>
                <li><strong>renderAttributes</strong>: renders the HTML5 attributes defined in the
                <em>attributes </em>variable.
                </li>
            </ul>
            <li><strong>blocks</strong>
            </li>
            <ul>
                <li><strong>component</strong>: the main block that contains all the logic to render
                a component
                </li>
                <li><strong>class</strong>: contains the class names for the component
                </li>
                <li><strong>attributes</strong>: contains the HTML5 attributes for the component
                </li>
                <li><strong>body</strong>: contains the body for the component. Use this block to
                fill a component with content
                </li>
            </ul>
            <li><strong>qa</strong>: Experimental custom HTML5 attribute that renders a list of items
            that can be used later in QA to address a specific component or part of it.
            </li>
        </ul>
        <p><strong>
        Builtin Twig
            Functions and Filters
    </strong>
        </p>
        <p>The following builtin twig functions and filters can be used in your components to enable them
    with builtin Shop Ui functionality:</p>
        <p>
            <h4>function model($modelName: string): string</h4>
            <p>Returns a string in the following format: <em>@ShopUi/models/<strong>modelName</strong>.twig</em></p>
            <p>The string is used internally to resolve the model location within the <strong>ShopUi</strong>
                module.
            </p>
            <p><strong>$modelName</strong> - model name <em>(required)</em></p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>function atom($componentName: string, $componentModule: string = "ShopUi"): string</h4>
            <p>The function is used to resolve <strong>atom</strong> paths. Returns a
                    string in the following format: <em>@componentModule/components/atoms/<strong>componentName</strong>/<strong>componentName</strong>.twig</em></p>
            <p>The string is used internally to resolve the component location
                within the provided module.
            </p>
            <p><strong>$componentName</strong> - component name <em>(required)</em></p>
            <p><strong>$componentModule</strong> - Spryker module in which the component is
                located <em>(optional)</em></p>
            <p>If <em>$componentModule </em>is not specified, then <strong>ShopUi</strong>
                is used.
            </p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>function molecule($componentName: string, $componentModule:
        string = "ShopUi"): string</h4>
            <p>The function is used to resolve <strong>molecule </strong>paths. Returns
                    a string in the following format: <em>@componentModule/components/<em>molecules</em>/<strong>componentName</strong>/<strong>componentName</strong>.twig</em></p>
            <p>The string is used internally to resolve the component location
                within the provided module.
            </p>
            <p><strong>$componentName</strong> - component name <em>(required)</em></p>
            <p><strong>$componentModule</strong> - Spryker module in which the component is
                located <em>(optional)</em></p>
            <p>If <em>$componentModule </em>is not specified, then <strong>ShopUi</strong>
                is used.
            </p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>function organism($componentName: string, $componentModule:
        string = "ShopUi"): string</h4>
            <p>The function is used to resolve <strong>organism </strong>paths. Returns
                    a string in the following format: <em>@componentModule/components/<em>organisms</em>/<strong>componentName</strong>/<strong>componentName</strong>.twig</em></p>
            <p>The string is used internally to resolve the component location
                within the provided module.
            </p>
            <p><strong>$componentName</strong> - component name <em>(required)</em></p>
            <p><strong>$componentModule</strong> - Spryker module in which the component is
                located <em>(optional)</em></p>
            <p>If <em>$componentModule </em>is not specified, then <strong>ShopUi</strong>
                is used.
            </p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>function template($templateName: string, $templateModule: string
        = "ShopUi"): string</h4>
            <p>The function is used to resolve <strong>template </strong>paths. Returns
                    a string in the following format: <em>@templateModule/templates/<strong>templateName</strong>/<strong>templateModule</strong>.twig</em></p>
            <p>The string is used internally to resolve the component location
                within the provided module.
            </p>
            <p><strong>$templateName</strong> - template name <em>(required)</em></p>
            <p><strong><strong>$template</strong>Module</strong> - Spryker
                module in which the template is located <em>(optional)</em></p>
            <p>If <em>$templateModule </em>is not specified, then <strong>ShopUi</strong> is
                used.
            </p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>function view($viewName: string, $viewModule: string =
        "ShopUi"): string</h4>
            <p>The function is used to resolve <strong>view </strong>paths. Returns
                    a string in the following format: <em>@viewModule/views/<strong>viewName</strong>/<strong>viewName</strong></em></p>
            <p>The string is used internally to resolve the component location
                within the provided module.
            </p>
            <p><strong>$viewName</strong> - view name <em>(required)</em></p>
            <p><strong><strong>$<strong>view</strong></strong>Module</strong> -
                Spryker module in which the view is located <em>(optional)</em></p>
            <p>If <em>$viewModule </em>is not specified, then <strong>ShopUi</strong> is
                used.
            </p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>function publicPath($relativePath: string): string</h4>
            <p>The function is used to provide a safe way to access the <strong>public </strong>folder
                        where compiled assets are located. Returns a string in the
                    following format: <em>public/path/relative/path</em></p>
            <p>The string is used internally to resolve the component location
                within the provided module.
            </p>
            <p><strong>$relativePath</strong> - asset relative path <em>(required)</em></p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>function qa($qaValues: string[] = []): string</h4>
            <p>Returns a string in the following format: <em>data-qa="qa values here"</em></p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>unction qa_*($qaName: string, $qaValues: string[] = []): string</h4>
            <p>Returns a string in the following format: <em>data-qa-name="qa values here"</em></p>
            <p><strong>$qaName</strong> - specifies the name to add in the left side of the data
            strucure.</p>
        </p>
        <p>
            <br />
        </p>
        <p>
            <h4>custom tag define</h4>
            <p>This function can be used for the following purposes:</p>
            <ul>
                <li>create a default object that can be changed from the incoming context;
                </li>
                <li>define tags used to pass properties and contract for a specific component.
                </li>
            </ul>
        </p>
        <p>Typical implementation:</p><pre><code class="language-CSS line-numbers">
{% extends model('component') %}

{% define config = {
    name: 'component-name',
    tag: 'tag'
} %}

{% define data = {
    ...
} %}

{% block body %}
    ...
{% endblock %}
    </code></pre>
        <h3>SCSS</h3>
        <p>A typical <em>component-name.scss</em> file looks as follows:</p><pre><code class="language-CSS line-numbers">
@mixin module-name-component-name($name: '.component-name') {
    #{$name} {
        // BEM styles

        @content;
    }
}
    </code></pre>
        <p>When defining styles for a component, you can include the global mixins, variables and styles as
    defined in the <em>ShopUi</em> module. They are exposed to every component by default. Also,
    you can use the styles and mixins of every built-in component, as they are exposed
    transparently to the poject level, for example:</p><pre><code class="language-CSS line-numbers">
@include shop-ui-side-drawer('.new-existing-component-side-drawer') { //Create component style based on mixin of a core component
    color: $setting-color-alt; // Use system-wide variables
 
    &amp;__overlay {
        background-color: $setting-color-main; // Use system-wide variables
    }
}
    </code></pre>
        <p>A component can also contain a <em>style.scss </em>file that imports the component
    style. In this case, <em>component-name.scss </em>just <strong>defines </strong>the
    style, while <em>style.scss</em> <strong>imports</strong> it, producing an output once. This is
    useful when a mixin might be used multiple times or extended. In that case, import via a
    separate file prevents the content to be rendered in the output every time a mixin is called.</p>
        <p class="tip">The use of a <em>style.scss </em>file is required for global components only,
            project-level components may ignore it.</p>
        <h3>Behavior</h3>
        <p>The <em>component-name.ts </em>file contains the typescript implementation defined as a
    custom element.</p>
        <p>The component class must element a DOM callback. You can use any callback defined by the <a class="external-link" style="text-decoration: none;" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="nofollow">Web Components Specification</a>. It is recommended to use <strong>ready </strong>callback.
    This callback is triggered when the component is ready and all other components have already
    been loaded in the DOM. It is the safest approach from the point of view of DOM
    manipulation.
    When the component receives the callback you define, it should execute the behavioral logic.</p>
        <p>In your code, you can use keyword <em>this</em> to access the public API
    of the HTML element associated with the component.</p>
        <p>Typical implementation:</p><pre><code class="language-Javascript line-numbers">
import Component from 'ShopUi/models/component';

export default class ComponentName extends Component {
    protected readyCallback(): void {
        // TODO: your code here
    }
} 
    </code></pre>
        <p>The above example extend the default <strong>Component</strong> model defined in the <em>ShopUi</em>
    application. However, you can extend from any component both on the global and on the project
    level. In this case, your new component will inherit the logic and behavior of the component it
    is derived from. The following example shows a component inherited from the default side-drawer
    component of Spryker Shop:</p><pre><code class="language-Javascript line-numbers">
// Import class SideDrawer
import SideDrawer from 'ShopUi/components/organisms/side-drawer/side-drawer';
 
// Export the extended class
export default class ComponentName extends SideDrawer {
    protected readyCallback(): void {
        // TODO: your code here
    }
}
    </code></pre>
        <h3>Index.ts</h3>
        <p>The <em>index.ts </em>file is required to load the client-side of the component with Webpack.
    The latter globs the system looking for these files and bundles them into an output file.
    Create this file whenever you need to include a style and/or a Typescript/Javascript file as
    part of the component.</p>
        <p style="text-align: left;">To register the component in the DOM,
        you need to use
        the <strong>register</strong> function of the shop application. It
        accepts <strong>2</strong> arguments:<br /></p>
        <ul style="text-align: left;">
            <li><strong>name</strong> - specifies the component's tag name. This name
        will be associated with the component and can be used in Twig to insert the component into
        a template. Also, it will be used in the DOM as a tag name. Whenever a tag with the
        specified name occurs in the DOM, the Shop Application will load the component.</li>
            <li>
                <p><strong>importer</strong> - must be a call
            of Webpack's <strong>import</strong> function to import
            Typescript code for the component. The call must include a Webpack magic comment that
            specifies which type of import you want for the component, 'lazy' or 'eager'. For
            details, see <a class="external-link" style="text-decoration: none;" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports" rel="nofollow">Dynamic Imports</a>.</p>
            </li>
        </ul>
        <p>Typical implementation:</p><pre><code class="language-Javascript line-numbers">
import './component-name.scss';

// Import the 'register' function from the Shop Application
import register from 'ShopUi/app/registry';
 
// Export the component behavior
export default register(
    'component-name',
    () =&gt; import(/* webpackMode: "lazy" */'./component-name')
);
    </code></pre>
        <p>See <a href="../../Resources/pdf/Modules to Components Mapping.pdf">Modules to Components Mapping</a> for description of modules and their components. <br /></p>
        <h1>What's Next</h1>
        <p>The following topics will help you in developing Spryker Atomic Frontend step-by-step:<br /></p>
        <ol>
            <li><a href="../../tutorials/introduction/customizefrontend/t-customize-spryker-frontend.htm">Tutorial - Customize Spryker Frontend</a>
            </li>
            <li><a href="../../tutorials/introduction/customizefrontend/t-create-component.htm">Tutorial - Frontend - Create a Component</a>
            </li>
            <li><a href="../../tutorials/introduction/customizefrontend/t-override-component.htm">Tutorial - Frontend - Override a Component</a>
            </li>
            <li><a href="../../tutorials/introduction/customizefrontend/t-extend-component.htm">Tutorial - Frontend - Extend a Component</a>
            </li>
            <li><a href="https://documentation.spryker.com/tutorials/introduction/customizefrontend/t-integrate-jquery.htm">Tutorial - Frontend - Integrate JQuery into Atomic Frontend</a>
            </li>
            <li><a href="https://documentation.spryker.com/tutorials/introduction/customizefrontend/t-use-component.htm#tutorial---frontend---use-a-component">Tutorial - Frontend - Use a Component</a>
            </li>
        </ol>
    </body>
</html>