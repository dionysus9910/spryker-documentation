<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="General.Draft">
    <head>
    </head>
    <body>
        <h1>Tutorial: OMS Invoice State Machine</h1>
        <p MadCap:conditions="General.Hidden Comment">used to be: http://spryker.github.io/onboarding/state-machine/</p>
        <h2>Challenge Description</h2>
        <p>Build a simple state machine that creates an invoice payment process. Add dummy commands and conditions and integrate it into checkout.</p>
        <h2>Challenge Solving Highlights</h2>
        <p>For this challenge, it was asked to create a state machine that models a simplified <b>invoice payment</b> process:</p>
        <ul>
            <li class="bullet_list">Create an <strong>invoice</strong> per <strong>order</strong>.</li>
            <li class="bullet_list">An <strong>invoice</strong> is represented by a (temporary) <strong>file</strong>.</li>
            <li class="bullet_list">We move to <var>invalid</var> state if creating the <strong>invoice</strong> fails, otherwise transition into <var>closed</var>.</li>
        </ul>
        <p>Bonus-Challenge: You can also include payment and shipment here for completeness.</p>
        <h2>Getting Started</h2>
        <p>You can start by drawing your state machine on paper and define it this way. If you don’t know where to start, one hint is to start with these two states:</p>
        <ol>
            <li>new</li>
            <li>invalid</li>
        </ol>
        <p>These two states allow you to at least have the starting point (new) and - as you should design for failure - the invalid endpoint state. In your further drawing you can then concentrate on the diverse states you need to go through in your state machine for order processing - aiming for success, to have a happy-path resolution endpoint.</p>
        <p>
            <img src="../../Resources/Images/state_machine_sketch.png" title="Click me" alt="State machine sketch" class="Thumbnail" />
        </p>
        <p>You’ll be able to see the definition of the state machine from the XML document in a graphical representation that can be displayed by your browser. So in your drawing you don’t need to concentrate on a perfectly sketched image, it’s more a high-level modeling of the state machine without the need to fiddle with XML files.</p>
        <p>Start drafting your state machine in <var>Invoice01.xml</var> under the <var>config/Zed/oms/</var> folder. You can use the existing <var>Nopayment01.xml</var> as a template.</p>
        <p>To activate this new state machine, modify your config:</p>
        <ul>
            <li class="bullet_list">Open the configuration file: <var>config/Shared/config_default.php</var></li>
            <li class="bullet_list">Add the state machine <var>Invoice01</var> to <var>OmsConstants::ACTIVE_PROCESSES</var></li>
        </ul><pre><code class="language-PHP line-numbers">&lt;?php
$config[OmsConstants::ACTIVE_PROCESSES] = [
    ...
    'Invoice01'
];</code></pre>
        <p MadCap:conditions="Spryker.DemoShop">Check the current state machine status in Zed: <a href="http://zed.de.demoshop.local/oms/" target="_blank">http://zed.de.demoshop.local/oms/</a>.</p>
        <h2>Completing the State Machine</h2>
        <p>We want to create an invoice and simulate that by creating a file in <var>/tmp/orders</var> for example. For this we will need an event “create invoice”.</p>
        <p>Afterwards we check that the file exists and if it doesn’t then go to the “invalid state”. The happy case should be the one that confirms that the invoice was created. It should then automatically move to the <var>closed</var> state, our end point. To build such a condition we will need two transitions, one going from “new" to “closed”, and one going from “new” to “invalid”. The <var>happy=true</var> is added to the first one.</p>
        <p>Check the drafted state machine in Zed to confirm that the state machine now looks as expected.</p>
        <h2>Adding Command and Condition to the State Machine</h2>
        <p>We now need to hook in our PHP logic.</p><pre><code class="language-PHP line-numbers">        ...

        &lt;events&gt;
            ...
            &lt;event name="create invoice" command="CreateInvoice" manual="true"/&gt;

        &lt;transitions&gt;
            ...
            &lt;transition happy="true" condition="IsInvoiceCreated"&gt;
                &lt;source&gt;new&lt;/source&gt;
                &lt;target&gt;closed&lt;/target&gt;
                &lt;event&gt;create invoice&lt;/event&gt;
            &lt;/transition&gt;
            &lt;transition&gt;
                &lt;source&gt;new&lt;/source&gt;
                &lt;target&gt;invalid&lt;/target&gt;
                &lt;event&gt;create invoice&lt;/event&gt;
            &lt;/transition&gt;</code></pre>
        <p>If you check the drafted state machine in Zed now, it will mark the condition and command as red (“not implemented”).</p>
        <h2>Implementing Command and Condition</h2>
        <p>As examples for commands and conditions, a few dummy ones have been provided in <var>Spryker\Zed\DummyPayment\Communication\Plugin\Oms\</var> namespace.</p>
        <p>Let’s implement the same <var>CommandByOrderInterface</var> interface.</p>
        <p>The invoice creation is faked by creating a file on disk to have a verifiable action. It merely consists of some file-system and error-handling code finally touching the file on disk:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Sales\Communication\Plugin\Oms\Command;

use Orm\Zed\Sales\Persistence\SpySalesOrder;
use RuntimeException;
use Spryker\Zed\Oms\Business\Util\ReadOnlyArrayObject;
use Spryker\Zed\Oms\Dependency\Plugin\Command\CommandByOrderInterface;

class CreateInvoiceCommand implements CommandByOrderInterface
{

    /**
     * ...
     *
     * @return array
     */
    public function run(array $orderItems, SpySalesOrder $orderEntity, ReadOnlyArrayObject $data)
    {
        /* create a fake invoice file */

        $base = sys_get_temp_dir();
        if (!strlen($base)) {
            throw new RuntimeException('Unable to obtain order base store folder (faked in tempdir)');
        }

        $dir = sprintf('%s/orders', $base);
        if (!is_readable($dir) &amp;&amp; !mkdir($dir)) {
            throw new RuntimeException('Unable to establish order store folder');
        }

        $path = sprintf('%s/invoice-order-%d', $dir, $orderEntity-&gt;getIdSalesOrder());

        touch($path);

        return [];
    }

}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>As shown, only the single <var>run()</var> method needs to be implemented to add actual operations within the state machine. By using the temporary directory, the operation is at least persisted until reboot, so it can be checked by condition.</p>
        <p>Similar to commands, conditions implement <var>Spryker\Zed\Oms\Communication\Plugin\Oms\Condition\ConditionInterface</var>, so does the <var>Pyz\Zed\Invoice\Communication\Plugin\Oms\Condition\IsInvoiceCreatedCondition</var>. It comes to life by implementing the <var>check()</var> method:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Sales\Communication\Plugin\Oms\Condition;

use Orm\Zed\Sales\Persistence\SpySalesOrderItem;
use Spryker\Zed\Oms\Dependency\Plugin\Condition\ConditionInterface;

class IsInvoiceCreatedCondition implements ConditionInterface
{

    /**
     * @param SpySalesOrderItem $orderItem
     *
     * @return bool
     */
    public function check(SpySalesOrderItem $orderItem)
    {
        $orderEntity = $orderItem-&gt;getOrder();

        $path = sprintf('%s/orders/invoice-order-%d', sys_get_temp_dir(), $orderEntity-&gt;getIdSalesOrder());

        return is_readable($path);
    }

}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>A rather straight forward check for file existence.</p>
        <p>This check on success (returning boolean true) will immediately trigger the next state, otherwise transition into the <var>invalid</var> state.</p>
        <h2>Enable the new Condition and Command</h2>
        <p>You need to hook in the new classes in your <var>OmsDependencyProvider</var>.</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Oms;

use Pyz\Zed\Sales\Communication\Plugin\Oms\Command\CreateInvoiceCommand;
use Pyz\Zed\Sales\Communication\Plugin\Oms\Condition\IsInvoiceCreatedCondition;
use Spryker\Zed\Kernel\Container;
use Spryker\Zed\Oms\OmsDependencyProvider as SprykerOmsDependencyProvider;

class OmsDependencyProvider extends SprykerOmsDependencyProvider
{

    /**
     * @param \Spryker\Zed\Kernel\Container $container
     *
     * @return \Spryker\Zed\Kernel\Container
     */
    public function provideBusinessLayerDependencies(Container $container)
    {
        $container = parent::provideBusinessLayerDependencies($container);
        $container-&gt;extend(self::COMMAND_PLUGINS, function (CommandCollectionInterface $commandCollection) {
            $commandCollection-&gt;add(new CreateInvoiceCommand(), 'CreateInvoice');

            return $commandCollection;
        });

        $container-&gt;extend(self::CONDITION_PLUGINS, function (ConditionCollectionInterface $conditionCollection) {
             $conditionCollection-&gt;add(new IsInvoiceCreatedCondition(), 'IsInvoiceCreated');

             return $conditionCollection;
        });

        return $container;
    }
    
}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>The drafted state machine should now not contain any red warnings anymore.</p>
        <h2>Initialize the State Machine for Every New Order in Checkout</h2>
        <ul>
            <li class="bullet_list">Open the configuration file: <var>config/Shared/config_default.php</var></li>
        </ul><pre><code class="language-PHP line-numbers">&lt;?php
$config[SalesConstants::PAYMENT_METHOD_STATEMACHINE_MAPPING] = [
    DummyPaymentConfig::PAYMENT_METHOD_INVOICE =&gt; 'Invoice01',
    ...
];</code></pre>
        <p>The next time you check out with the “Invoice” payment type, the new <var>Invoice01</var> state machine will be used.</p>
        <h2>Testing the State Machine</h2>
        <p>Check the Sales backend, click “create invoice” and see how the order will move into the <var>closed</var> state, also see the transition log in the details view.</p>
        <p>The implementation of the command can then be easily tested by checking the <var>/tmp/orders/</var> folder on the VM after placing the order:</p><pre><code class="language-PHP line-numbers">ls -l /tmp/orders
==================
-rw-r--r--  1 www-data www-data    0 Apr 24 13:58 invoice-order-5
-rw-r--r--  1 www-data www-data    0 Apr 24 14:07 invoice-order-6
-rw-r--r--  1 www-data www-data    0 Apr 24 14:09 invoice-order-7
-rw-r--r--  1 www-data www-data    0 Apr 24 14:11 invoice-order-8</code></pre>
        <p>Et voilá, let the orders flow in. Each order will give you a new invoice (if the correct payment has been chosen) with this example of state machine.</p>
        <h2>Tips and Tweaks</h2>
        <p>You can add <var>onEnter="true"</var> to the “create invoice” event if you want it to automatically create the invoice as soon as the checkout completes. This way no additional click in the backend will be necessary anymore.</p>
        <p>Also, you can return hard-coded <var>false</var> in the condition to check if moving to “invalid” works, as well.</p>
    </body>
</html>