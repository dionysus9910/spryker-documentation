<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
        <link href="../Resources/TableStyles/PatternedRows2.css" rel="stylesheet" MadCap:stylesheetType="table" />
    </head>
    <body>
        <h1>Performance Guidelines</h1>
        <p>Spryker is a fast application by design. This guideline explains how to optimize the server-side execution time.</p>
        <h2>Hosting Recommendations</h2>
        <ul>
            <li><b>CPU</b>: Spryker's execution time depends on the CPU of the server. In general, we can say that more CPU capacity supports faster response times and allows a higher load.</li>
            <li><b>Memory (Databases)</b>: Databases (Redis, Elasticsearch, and PostgreSQL) mainly consume RAM.  When there is not enough RAM, you'll see performance issues. The best amount of RAM depends on the amount of data that you have and needs to be measured from time to time.</li>
            <li><b>Memory (PHP)</b>: The amount of memory does not have an impact on the execution time of PHP, but to squeeze everything out of your server you'll need to define the <var>pm.max_children</var> configuration value of PHP-FPM. The max amount of parallel processes must not be higher than the available memory divided by the maximum consumption per process.</li>
            <li><b>Latency</b>: You'll see the highest speed of Spryker when Redis is installed on the same machine than the application to avoid latency. Redis has a blazing fast response time of 0.1ms, but in cloud environments, you'll often get additional 1-3ms of latency per <var>get()</var>. A caching mechanism that uses Spryker is described below. </li>
        </ul>
        <h2>Disable Xdebug</h2>
        <p>Xdebug slows down the application a lot and is not necessary for a non-development environment.</p>
        <h2>Use the Newest Version of PHP</h2>
        <p>For performance reason, you should always use the newest stable version of PHP, as every new version ships with several improvements.</p>
        <h2>Opcache Activation</h2>
        <p>Make sure that the Opcache is activated and well configured.</p>
        <table style="width: 100%;mc-table-style: url('../Resources/TableStyles/PatternedRows2.css');" class="TableStyle-PatternedRows2" cellspacing="0">
            <col style="width: 231px;" class="TableStyle-PatternedRows2-Column-Regular" />
            <col style="width: 394px;" class="TableStyle-PatternedRows2-Column-Regular" />
            <col style="width: 180px;" class="TableStyle-PatternedRows2-Column-Regular" />
            <col class="TableStyle-PatternedRows2-Column-Regular" />
            <thead>
                <tr class="TableStyle-PatternedRows2-Head-Header1">
                    <td class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Configuration</td>
                    <td class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Purpose </td>
                    <td class="TableStyle-PatternedRows2-HeadE-Regular-Header1">Production</td>
                    <td class="TableStyle-PatternedRows2-HeadD-Regular-Header1">Development</td>
                </tr>
            </thead>
            <tbody>
                <tr class="TableStyle-PatternedRows2-Body-LightRows">
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>opcache.enable</var>
                    </td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Activates opcache for web requests. Most developers disable this on development environments to avoid outdated code in caches, but you can also activate it and check for changed files via

<var>validate_timestamps</var> and <var>revalidate_freq</var> configurations.</td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">1</td>
                    <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">0</td>
                </tr>
                <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>opcache.enable_cli</var>
                    </td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">Activates opcache for console comands</td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">1</td>
                    <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows">0</td>
                </tr>
                <tr class="TableStyle-PatternedRows2-Body-LightRows">
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>opcache.max_accelerated_files</var>
                    </td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Spryker and all the used open source libraries contain a lot of PHP classes, so this value should be high (Max is 100k)</td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">?</td>
                    <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">8192</td>
                </tr>
                <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows"><var>opcache.memory_consumption</var>
                    </td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">To avoid an automatic reset of the opcache, these values must be high enough. You can look into the PHP info (e.g., in Zed browse to <var>/maintenance/php-info</var>) to see the current usage. You can count the number of classes in your code base to get a feeling for good value here.</td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-DarkerRows">?</td>
                    <td class="TableStyle-PatternedRows2-BodyD-Regular-DarkerRows">&#160;</td>
                </tr>
                <tr class="TableStyle-PatternedRows2-Body-LightRows">
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows"><var>opcache.validate_timestamps</var>
                    </td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">Boolean values that activates the check for the updated code. This check is time-consuming and should be disabled in production environments. However, you'll need to flush the cache during deployments (e.g., by restarting PHP).</td>
                    <td class="TableStyle-PatternedRows2-BodyE-Regular-LightRows">0</td>
                    <td class="TableStyle-PatternedRows2-BodyD-Regular-LightRows">1</td>
                </tr>
                <tr class="TableStyle-PatternedRows2-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows2-BodyB-Regular-DarkerRows"><var>opcache.revalidate_freq</var>
                    </td>
                    <td class="TableStyle-PatternedRows2-BodyB-Regular-DarkerRows">This configures the frequency of checks (if enabled via the <var>validate_timestamps</var> configuration). "0" means on every request which is recommended for development environments in case you want to program with activated opcache.	0	0
</td>
                    <td class="TableStyle-PatternedRows2-BodyB-Regular-DarkerRows">0</td>
                    <td class="TableStyle-PatternedRows2-BodyA-Regular-DarkerRows">0</td>
                </tr>
            </tbody>
        </table><![CDATA[
		
		
		]]><pre><code class="language-PHP line-numbers">zend_extension=opcache.so
opcache.enable=1
opcache.enable_cli=1
opcache.max_accelerated_files=8192
opcache.memory_consumption=256
 
; Check if file updated on each request - for development
opcache.validate_timestamps=0
opcache.revalidate_freq=0</code></pre><h2>Optimized Composer Autoloader</h2><p>
    A typical request in Yves required up to 1000 PHP classes. Much time is needed to translate the class
    name to a filename. Composer is shipped with an autoloader that checks several paths to find a specific class.
    Composer also offers an optimized autoloader which creates a map with all classes and their locations
    in the <var>vendor/composer/</var> directory. This map speeds up the autoloading by ~50%, and we recommend to run
    this during every deployment.
</p><pre><code class="language-PHP">php composer.phar dumpautoload -o</code></pre><p>You can also optimize autoloader by enabling some options in <var>composer.json</var>:</p><pre xml:space="preserve"><code class="language-JSON">"optimize-autoloader": true,
 "classmap-authoritative": true</code></pre><p>
    You can find more details about composer autoloader optimization
    <a href="https://getcomposer.org/doc/articles/autoloader-optimization.md" target="_blank">here.</a></p><h2>Deactivate All Debug Functions And the Symfony Toolbar</h2><p>The <var>config_default-production.php</var> file should disable all debuggers and the Symfony toolbar.</p><pre><code class="language-PHP line-numbers">$config[ApplicationConstants::ENABLE_APPLICATION_DEBUG] = false;
$config[ApplicationConstants::ENABLE_WEB_PROFILER] = false;
$config[PropelConstants::PROPEL_DEBUG] = false;</code></pre><h2>
Activate Twig Compiler

</h2><p>Twig files can be pre-compiled into PHP classes to speed it up. It can be activated in the configuration. We highly recommend using the <var>FORCE_BYTECODE_INVALIDATION</var> option. Otherwise, the opcache may contain outdated content, as these files are modified during runtime.</p><pre><code class="language-PHP line-numbers">$config[TwigConstants::ZED_TWIG_OPTIONS] = [
   'cache' =&gt; new Twig_Cache_Filesystem(sprintf(
		'%s/data/%s/cache/Zed/twig',
		 APPLICATION_ROOT_DIR, $CURRENT_STORE),
		 Twig_Cache_Filesystem::FORCE_BYTECODE_INVALIDATION),
];
 
$config[TwigConstants::YVES_TWIG_OPTIONS] = [
	'cache' =&gt; new Twig_Cache_Filesystem(sprintf(
		'%s/data/%s/cache/Yves/twig',
		 APPLICATION_ROOT_DIR, $CURRENT_STORE),
		 Twig_Cache_Filesystem::FORCE_BYTECODE_INVALIDATION),
];</code></pre><h2>Activate Twig Path Cache</h2><p>Twig files can be in a lot of places. To avoid time consuming searches, we recommend to activate the path cache.</p><pre><code class="language-PHP line-numbers">$config[TwigConstants::YVES_PATH_CACHE_FILE] = sprintf(
	'%s/data/%s/cache/Yves/twig/.pathCache',
	APPLICATION_ROOT_DIR,
	$CURRENT_STORE
);
$config[TwigConstants::ZED_PATH_CACHE_FILE] = sprintf(
	'%s/data/%s/cache/Zed/twig/.pathCache',
	APPLICATION_ROOT_DIR,
	$CURRENT_STORE
);</code></pre><h2>Activate Zed Navigation Cache (Default On)</h2><p>The navigation of Zed is defined in XML files that need to be parsed and merged. As it does not happen quite often, it is recommended to keep the cache activated all the times (even during development) and to run <var>vendor/bin/console navigation:build-cache</var> only when anything has changed.</p><pre><code class="language-PHP">$config[ZedNavigationConstants::ZED_NAVIGATION_CACHE_ENABLED] = true;</code></pre><h2>
Activate Class Resolver Cache

</h2><p>Spryker allows to extend some classes (like facades, clients, etc.) in projects and also for multiple stores. Therefore each class can exist on core-, project- and store-level. We also support multiple namespaces for each level, so there are several possible places for any of these classes. To avoid unnecessary usages of the expensive <var>class_exists()</var> function, Spryker provides a caching mechanism that writes all non-existing classes into a cache file (see for example <var>/data/DE/cache/Yves/unresolvable.cache</var>, the same applies for different stores and Zed as well). This cache file must be removed during every deployment, and it is not recommended to active this during development.</p><pre><code class="language-PHP">$config[KernelConstants::AUTO_LOADER_UNRESOLVABLE_CACHE_ENABLED] = true;</code></pre><h2>
		Redis Mget Cache (Default: On)

</h2><p>Yves performs a high number of <var>get()</var> calls to Redis. In case Redis is installed on the same machine, then the expected time per <var>get()</var> is below 0.1 ms. However, in case you run Spryker on a cloud environment, there is latency for each <var>get()</var> call to Redis. It can sum up to a few hundred milliseconds per request. To avoid this performance bottleneck, Spryker remembers all used <var>get()</var> calls per URL and performs a single <var>mget()</var> to retrieve all needed data in one call. This behavior works out of the box. In case you see a high number of <var>get()</var> calls in your monitoring, you should make sure that the <var>StorageCacheServiceProvider</var> is registered in <var>YvesBootstrap</var>. This provider is responsible for the persistence of the cache data in Redis. For more information about the Redis Mget cache <a href="https://documentation.spryker.com/yves/redis-as-kv.htm?Highlight=redis%20as%20kv#using-redis-cache">this article</a>.</p><p>&#160;</p><p><i>Last review date:&#160;Jan. 23rd, 2019 </i><MadCap:conditionalText MadCap:conditions="General.Hidden Comment"><i>by Mykola Ostrizhnii, Oksana Karasyova</i></MadCap:conditionalText></p></body>
</html>