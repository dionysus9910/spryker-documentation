define({"837":{i:0.00366474698552642,u:"../capabilities/order_management/state_machine/state-machine-patterns.htm",a:" Process Patterns The State Machine Cook Book describes how to build a state machine with the elements state, transition and event. However there are some recurring design problems that are needed in many processes. In this article common problems and their solution with state machine snippets are ...",t:"State Machine Patterns    "},"838":{i:0.000722882719801972,u:"../capabilities/development/event/event-asynch.htm",a:"Asynchronous Events  An asynchronous event can be created by using the addListenerQueued method instead of addListener. The difference is that it queues the event to be processed later by another process/consumer. You must have queue configured before using this feature, see bellow.",t:"Asynchronous Events "},"839":{i:0.00356070728514612,u:"../capabilities/order_management/state_machine/state-machine-persistence.htm",a:" To persist the state of the item and make the connection with the state machine, you need to store related data into the database. For example, you can create two fields (idStateMachineState(int) and idStateMachineProcess(int)) and store their id’s when itemStateUpdated is being triggered.   See ...",t:"Persistence - State Machine    "},"840":{i:0.000722882719801972,u:"../capabilities/development/event/event-priority.htm",a:" The Event Collector \\Spryker\\Service\\Event\\Dependency\\EventCollectionInterface uses a priority queue store events so each that event can have different priority and will be executed in correct order when triggered. For example: \u003c?php\n$eventCollection\n    ...",t:"Listener Priority "},"841":{i:0.000747773698863074,u:"../resources/gluepublicspec/swagger-ui/oauth2-redirect.html",a:"    \u0027use strict\u0027;\n    function run () {\n        var oauth2 = window.opener.swaggerUIRedirectOauth2;\n        var sentState = oauth2.state;\n        var redirectUrl = oauth2.redirectUrl;\n        var isValid, qp, arr;\n\n        if (/code|token|error/.test(window.location.hash)) {\n            qp = window.location.hash.substring(1);\n        } else {\n            qp = location.search.substring(1);\n        }\n\n        arr = qp.split(\"\u0026\")\n        arr.forEach(function (v,i,_arr) { _arr[i] = \u0027\"\u0027 + v.replace(\u0027=\u0027, \u0027\":\"\u0027) + \u0027\"\u0027;})\n        qp = qp ? JSON.parse(\u0027{\u0027 + arr.join() + \u0027}\u0027,\n                function (key, value) {\n                    return key === \"\" ? value : decodeURIComponent(value)\n                }\n        ) : {}\n\n        isValid = qp.state === sentState\n\n        if ((\n          oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n          oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n        ) \u0026\u0026 !oauth2.auth.code) {\n            if (!isValid) {\n                oauth2.errCb({\n                    authId: oauth2.auth.name,\n                    source: \"auth\",\n                    level: \"warning\",\n                    message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn\u0027t returned from auth server\"\n                });\n            }\n\n            if (qp.code) {\n                delete oauth2.state;\n                oauth2.auth.code = qp.code;\n                oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n            } else {\n                let oauthErrorMsg\n                if (qp.error) {\n                    oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                        (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                        (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                }\n\n                oauth2.errCb({\n                    authId: oauth2.auth.name,\n                    source: \"auth\",\n                    level: \"error\",\n                    message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                });\n            }\n        } else {\n            oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n        }\n        window.close();\n    }\n",t:"oauth2-redirect"},"842":{i:0.000508861610403281,u:"../capabilities/internationalization/glossary/glossary-keys.htm",a:" Glossary keys present two layers of persistence: SQL database storage in-memory key-value storage (Redis) In this section we’ll exemplify the usage of the functionality for managing the glossary keys from the backoffice user interface and the usage of them for the Yves interface through twig ...",t:"Managing Glossary Keys    "},"843":{i:0.00122887122635246,u:"../capabilities/shipment/shipment-overview.htm",a:" The main concepts regarding shipping that are modeled in the database are : shipment carrier shipment method The shipment method is linked to the sales order. The schema below shows how these entities are modeled in the database : A sales order has associated a shipment method. Each shipment method ...",t:"Shipment Overview  "},"844":{i:0.000474859496668969,u:"../capabilities/back_office/manage-customer-accounts.htm",a:" ML Multi-language Customer Accounts are the area of the Administration Interface where you can view and edit customer accounts, see details and check order history. From Customer Accounts you can group customers to target them for exclusive or limited offers.  How are Accounts Created?\n Customers ...",t:"Manage Customer Accounts"},"845":{i:0.000498055496535954,u:"../capabilities/payment/how_to_implement_prepayment/ht-prepayment-checkout.htm",a:" The next step is to integrate prepayment into Checkout. In the PaymentMethods/Dependency/Injector from Yves add the CheckoutDependencyInjector that will inject the prepayment form and handler into the Checkout module:\n Click to expand the code sample \u003c?php\n\nnamespace ...",t:"HowTo — Integrate Prepayment into Checkout   "},"846":{i:0.000722882719801972,u:"../capabilities/development/event/event-adding.htm",a:" When adding an event, make sure you first decide what kind of events you want to trigger in your code. Events are stored in a class for later use, by adding its literal string value (ModuleName.subject.action). This value uniquely identifies an event in the event module, and all listeners attached ...",t:"Adding Events "},"847":{i:0.000617845791825305,u:"../capabilities/development/event/event-listen.htm",a:" There are two ways to listen to events, using direct listeners or subscribers. The difference between these two is that a subscriber allows the module providing the subscriber to wire up the handlers in the module that owns it without touching the EventDependencyProvider exception’s initial ...",t:"Listening to Events "},"848":{i:0.000810513822616751,u:"../capabilities/mailing_and_notifications/mail.htm",a:" Sending mail is a standard web application task. There are many cases where an action triggers an email to be sent. These actions can be newsletter subscriptions, order placement, refunds, customer account registration, etc. The Mail module helps you to create emails to be sent. To send an email ...",t:"Mail   "},"849":{i:0.000498055496535954,u:"../capabilities/payment/how_to_implement_prepayment/ht-prepayment-shared.htm",a:" As you can see, we need to identify the new payment type through some unique constants which we’re going to define under the Shared namespace, since they’re needed both by Yves and Zed.\n\n Create the PaymentMethodsConstants interface in the Shared namespace, where you’ll define these constants.\n\n ...",t:"HowTo - Implement Prepayment Shared   "},"850":{i:0.00285742186994178,u:"../capabilities/development/install-tool.htm",a:" Spryker offers an install tool which can be used to install the system as described in the install recipe file(s). Installation Install the module with composer by running the following command: \n        composer require spryker/install\n         After the installation you can run the command with ...",t:"Install Tool    "},"851":{i:0.000498055496535954,u:"../capabilities/payment/how_to_implement_prepayment/ht-prepayment-be.htm",a:" To integrate the prepayment method into the checkout, we are required to provide implementations for these 2 plugins:\n\n CheckoutPreCondition  PaymentSaveOrder  Add the following 2 plugins in Zed, inside the Communication/Plugin/Checkout folder of the new added module.\n\nPrepaymentPreCheckPlugin:\n ...",t:"HowTo - Implement Prepayment Back End   "},"852":{i:0.00347448533009752,u:"../capabilities/order_management/state_machine/state-machine-events.htm",a:" There are two main triggers: first one StateMachineFacade::triggerForNewStateMachineItem() is used when first time triggering the state machine for an item; this trigger will initialize the state machine and start transition through states until a decision without event, timeout or manual event is ...",t:"Triggering Events - State Machine    "},"853":{i:0.000639175119220361,u:"../capabilities/payment/how_to_implement_invoice_payment/ht-invoice-payment-fe.htm",a:" Creating the Form\n In Yves, we’ll start by building the form. Add the new module also in Yves and add a Form/ folder where we’ll place the implementation for building the form.\n\n First add the data provider, inside the Form/DataProvider/ folder:\n Click to expand the code sample \u003c?php\nnamespace ...",t:"HowTo - Implement Invoice Payment Front End   "},"854":{i:0.0019536794357396,u:"../capabilities/development/file_system/filesystem-api.htm",a:" Read API  getMetadata(FileSystemQueryTransfer $fileSystemQueryTransfer) Return FileSystemResourceMetadataTransfer, null on failure \u003c?php\n$fileSystemQueryTransfer = new ...",t:"File System API "},"855":{i:0.000639175119220361,u:"../capabilities/payment/how_to_implement_invoice_payment/ht-invoice-payment-be.htm",a:" Checkout Plugins\n To integrate the invoice payment method into the checkout, we need to provide implementations for these 2 plugins: CheckoutPreCondition PaymentSaveOrder Add the following 2 plugins in Zed, under the Communication/Plugin/Checkout/ folder of the new added module.\n\n ...",t:"HowTo - Implement Invoice Payment Back End   "},"856":{i:0.00110364478293433,u:"../capabilities/order_management/url-handling-new-entity.htm",a:" The following information describes how to handle URLs for other types of entities that Spryker core provides. Prerequisites Before you begin, make sure the target entity is already in your database (the one to you would like to assign URLs to). In the examples below we\u0027ll call this entity ...",t:"Handling New Types of Entity URLs "},"857":{i:0.000508861610403281,u:"../capabilities/internationalization/glossary/glossary-how-translations-managed.htm",a:" The key concept for rendering web pages with translated content very fast and with limited resource usage is using a key-value storage. Yves has no connection to Zed’s SQL database and it fetches all dynamic data from a key-value storage(Redis) and a search engine(Elasticsearch). This data contains ...",t:"How Translations are Managed    "},"858":{i:0.000493872356618593,u:"../industry_partners/payment/payone/legacy_demoshop/v1_0/payone-v1-0.htm",a:" Partner Information We integrate with a wide range of payment methods that can be configured according to your needs and convenience. Payment method flows are configured using state machines.\n\n Payone provides seven main methods of payment:\n\n Credit Card Direct Debit\n Online Transfer Paypal ...",t:"Payment Integration - BS PayOne - 1.0"},"859":{i:0.00375548121152843,u:"../capabilities/development/collector/collector-running.htm",a:" Each Collector is executed once for each Locale that’s configured in the Store. To see the currently configured locales, check the stores.php configuration file.\n\nThere are three commands which handle collectors related tasks.\n\n console collector:search:export\nconsole ...",t:"Running Collectors "},"860":{i:0.000638872968353728,u:"../capabilities/development/event/event.htm",a:" The Event module implements an Observer pattern where you can add hooks (events) to your code and allow other modules to listen and react to those events.\n\n There are two methods:\n\n Traditional Synchronous where listeners are handled at the same time as they are dispatched\n Asynchronous (Queueable) ...",t:"Event"},"861":{i:0.000498055496535954,u:"../capabilities/payment/how_to_implement_direct_debit/dd-shared-implementation.htm",a:" \nAs you can see, we need to identify the new payment type through some unique constants which we’re going to define under the Shared namespace, since they’re needed both by Yves and Zed.\n\n Create the PaymentMethodsConstants interface under the Shared namespace, where you’ll define these constants.\n ...",t:"Direct Debit Shared Implementation   "},"862":{i:0.00163233336279052,u:"../capabilities/search_and_filter/search.htm",a:" One of the most important features in an e-commerce application is to give the customer the ability to find the products that he needs. Depending on how easy it is to find the products the customer is searching for and how relevant the search results are, the search feature is a crucial aspect for ...",t:"Search    "},"863":{i:0.000498055496535954,u:"../capabilities/payment/how_to_implement_direct_debit/dd-fe-implementation.htm",a:" Create a form\n In Yves, we start by building the form.  Add the new module also in Yves and add a Form/ folder where we’ll place the implementation for building the form.\n\n First add the data provider, inside the Form/DataProvider/ folder:\n Click to expand the code sample \u003c?php\nnamespace ...",t:"Direct Debit Front-end Implementation   "},"864":{i:0.000498055496535954,u:"../capabilities/payment/how_to_implement_prepayment/ht-prepayment-fe.htm",a:" Creating the Form\n In Yves, we’ll start by building the form. Add the new module also in Yves and add a Form/ folder where we’ll place the implementation for building the form.\n\n First add the data provider, under Form/DataProvider:\n Click to expand the code sample \u003c?php\nnamespace ...",t:"HowTo - Implement Prepayment Front End   "},"865":{i:0.00106972423160645,u:"../capabilities/navigation/t-add-navigation-zed.htm",a:" This tutorial describes how to make your new controller action accessible in the navigation bar. There are two locations where you can define the navigation config : In the global config/Zed/navigation.xml config file Within your module in src/Pyz/Zed/{moduleName}/Communication/navigation.xml ...",t:"Tutorial - Adding Navigation in Zed  "},"866":{i:0.000635485386794564,u:"../capabilities/search_and_filter/dynamic-filters-functionality.htm",a:" ML Multi-language In Zed there’s a section (Search and Filters -\u003e Filter Preferences) for managing the product attributes that you’d like to filter by in the shop. There are several filter types that the framework supports at the moment: single-select: filter for one value at a time (e.g. radio ...",t:"Dynamic Filters Functionality"},"867":{i:0.000498055496535954,u:"../capabilities/payment/how_to_implement_invoice_payment/ht-invoice-payment-checkout.htm",a:" The next step is to integrate the invoice payment into Checkout. In the PaymentMethods/Dependency/Injector from Yves add the CheckoutDependencyInjector that will inject the invoice form and handler into the Checkout module:\n Click here to expand the code sample \u003c?php\n\nnamespace ...",t:"HowTo — Integrate Invoice Payment into Checkout"},"868":{i:0.000481493201955092,u:"../capabilities/product_management/product_relation/product-relation-types.htm",a:" In Spryker currently there are two types of relations:\n\n Related-products, related products displayed in the product detail page for the currently selected abstract product.\n Up-selling, related products displayed in the cart overview page, related products are from a list of abstract product ids ...",t:"Product Relation Types    "},"869":{i:0.00349154608521217,u:"../capabilities/order_management/sales/sales.htm",a:" The Sales module provides the order management functionality. The functionality is obtained through the ZED UI that renders orders with orders details and the Client API to get customer orders. Getting Totals for Order To get the Order with totals, the facade method ...",t:"Sales    "},"870":{i:0.000477094965301093,u:"../capabilities/development/zed_api/zed-api-processor-stack.htm",a:" Request and Pre Processing\n We now need to decide further on the URL format. Should this be extension driven, which is easier to browse, or HTTP header driven, for example? What kind of URL query string transformation do we need, what kind of header parsing is required?\n\n In order to keep this ...",t:"Processor Stack - Zed API    "},"871":{i:0.000481493201955092,u:"../capabilities/product_management/product_relation/product-relation-yves-datatastore.htm",a:" The product relation collector exports relations to the Yves data store.  This collector is located in the ProductRelationCollector module.\n \nInclude this module in your composer.json file and update. Then add the plugin ProductRelationCollectorPlugin from this module to ...",t:"Yves Datastore Collector - Product Relation    "},"872":{i:0.00106972423160645,u:"../capabilities/navigation/module-navigation.htm",a:" Overview The Navigation module manages multiple navigation menus that can be displayed on the frontend (Yves). Every navigation section can contain its own nested structure of navigation nodes. Navigation nodes have types that help define what kind of link they represent. The following node types ...",t:"Navigation Module  "},});