<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="">
    <head>
        <link href="../Resources/TableStyles/PatternedRows2.css" rel="stylesheet" MadCap:stylesheetType="table" />
    </head>
    <body>
        <h1>Core Extension</h1>
        <p MadCap:conditions="General.Hidden Comment">http://spryker.github.io/development-guide/reference/container-globals/</p>
        <p>We offer several ways like plugins to hook into the core’s behavior and extend this without modifications. But sometimes this is not enough, so you need to replace a method which is deep in the core.

</p>
        <p>Before your proceed, double check if there is no other way to solve your requirement, maybe there is facade method which fits in or you can use plugins. It is important to understand that if you do a core extension, you are behind the stable internal APIs, so there is no guarantee that the extended class is not modified, renamed or even non existing in the next release. Therefore you take over responsibility for your extension and it is highly recommended to cover it with unit tests. In case it is not urgent you can request a change in our support desk to get an official extension point.

</p>
        <p>There are three ways to extend classes from the core:

</p>
        <ul>
            <li class="bullet_list">replacement
class </li>
            <li class="bullet_list">inheritance
object </li>
            <li class="bullet_list">composition.
</li>
        </ul>
        <p>Each of them has its advantages and disadvantages.

</p>
        <h2>Extension via replacement
</h2>
        <p>In case you want to completely replace a class from the core, you can add a class which contains all the <var>public </var>methods from the original class and implements the same interface.

</p>
        <h2>Extension via class inheritance
</h2>
        <p>You can extend a class from the core and overwrite just the <var>public </var>or <var>protected </var>methods you need. This works well, because internally there are almost no <var>private </var>methods and no <var>final </var>classes.
</p>
        <p>
Inheritance is easy to do but it creates a tight coupling to a concrete class. There is high chance that a change in parent implementation will force a change in the sub class. Your effort for future updates will be higher.
</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\MyBundle\Business\Model;

use Spryker\Zed\MyBundle\Business\Model\AnyModel as SprykerAnyModel;

class AnyModel extends SprykerAnyModel
{
    // here you can overwrite public or protected methods from the core
}
</code></pre>
        <h2>Extension via object composition
</h2>
        <p>As an alternative to class inheritance you can also implement a composition of objects. This approach is more flexible and more robust but it requires more work in the initial implementation. You need to implement the same interface and provide all public methods. So you need to copy over some lines of code form the core to the project. This way you take over more control about this code.
</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\MyBundle\Business\Model;

use Spryker\Zed\MyBundle\Business\Model\AnyModelInterface

class AnyModel implements AnyModelInterface
{
    
    /**
      * @var AnyModelInterface
      */
    private $anyModelFromCore;
    
    public function __construct(AnyModelInterface $anyModelFromCore)
    {
        $this-&gt;anyModelFromCore = $anyModelFromCore;
    }
    
    // The interfaces forces you to add all public methods. 
    // This gives you nice hooks into the code.

    public function a()
    {
        return $this-&gt;anyModelFromCore-&gt;a();
    }
    
    public function b()
    {
        return $this-&gt;anyModelFromCore-&gt;b();
    }
    
    public function c() 
    {
        return $this-&gt;anyModelFromCore-&gt;c();
    }
    
}</code></pre>
        <h2>
Add your class to the factory
</h2>
        <p>When you extend a class from the core, you want the core code go use that one instead of the original class. To do so you need to add a <a href="factory.htm">factory</a> into the same module and same layer. This factory must extend its equivalent from the core. Core will automatically detect the overwritten factory and use it. Now you can easily exchange the classes and your extension.
</p>
        <p><b>Example</b>:</p>
        <table style="width: 100%;mc-table-style: url('../Resources/TableStyles/PatternedRows2.css');" class="TableStyle-PatternedRows" cellspacing="0">
            <col class="TableStyle-PatternedRows-Column-Regular" />
            <col class="TableStyle-PatternedRows-Column-Regular" />
            <thead>
                <tr class="TableStyle-PatternedRows-Head-Header1">
                    <th class="TableStyle-PatternedRows-HeadE-Regular-Header1">Path	</th>
                    <th class="TableStyle-PatternedRows-HeadD-Regular-Header1">Description
</th>
                </tr>
            </thead>
            <tbody>
                <tr class="TableStyle-PatternedRows-Body-LightRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-LightRows">
                        <p>Pyz\Zed\MyBundle\Business\MyBundleBusinessFactory</p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-LightRows">
                        <p>Factory in project-level</p>
                    </td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows-BodyB-Regular-DarkerRows">
                        <p>	
Spryker\Zed\MyBundle\Business\MyBundleBusinessFactory	</p>
                    </td>
                    <td class="TableStyle-PatternedRows-BodyA-Regular-DarkerRows">
                        <p>Factory in core-level
</p>
                    </td>
                </tr>
            </tbody>
        </table>
        <h2>Factory in case of class inheritance
</h2><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\MyBundle\Business;
use Pyz\Zed\MyBundle\Business\Model\AnyModel;

use Pyz\Zed\MyBundle\MyBundleConfig;
use Pyz\Zed\MyBundle\Persistence\MyBundleQueryContainer;
use Spryker\Zed\MyBundle\Business\Block\BlockManager;
use Spryker\Zed\MyBundle\Business\MyBundleBusinessFactory as SprykerMyBundleBusinessFactory;

/**
 * @method MyBundleConfig getConfig()
 * @method MyBundleQueryContainer getQueryContainer()
 */
class MyBundleBusinessFactory extends SprykerMyBundleBusinessFactory
{
    
    public function createAnyModel()
    {
        // Returns your sub-class which inherits from the core. 
        // If needed you can inject any dependencies here as well.
        return new AnyModel();
    }
    
}
</code></pre>
        <h2>Factory in case of composition
</h2><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\MyBundle\Business;

use Pyz\Zed\MyBundle\Business\Model\AnyModel;

use Pyz\Zed\MyBundle\MyBundleConfig;
use Pyz\Zed\MyBundle\Persistence\MyBundleQueryContainer;
use Spryker\Zed\MyBundle\Business\Model\AnyModel as SprykerAnyModel;
use Spryker\Zed\MyBundle\Business\MyBundleBusinessFactory as SprykerMyBundleBusinessFactory;

/**
 * @method MyBundleConfig getConfig()
 * @method MyBundleQueryContainer getQueryContainer()
 */
class MyBundleBusinessFactory extends SprykerMyBundleBusinessFactory
{
    
    public function createAnyModel()
    {
        // First you need to instantiate the original class from core.
        // If needed you can inject any dependencies here as well.
        $anyModelFromCore = new SprykerAnyModel( // TODO parent::createAnyModel();
            $this-&gt;getAnyDependency(),
            $this-&gt;getAnyOtherDependency()
        )
        
        // Now you create the composed object which gets the original class injected
        return new AnyModel(anyModelFromCore); // TODO OWN CREATE METHOD
    }
    
}
</code></pre>
    </body>
</html>