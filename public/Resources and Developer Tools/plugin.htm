<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:lastBlockDepth="5" MadCap:lastHeight="45512" MadCap:lastWidth="1649">
    <head>
        <link href="../Resources/TableStyles/PatternedRows.css" rel="stylesheet" MadCap:stylesheetType="table" />
    </head>
    <body>
        <h1>Plugin</h1>
        <p MadCap:conditions="General.Hidden Comment">http://spryker.github.io/development-guide/reference/plugin/</p>
        <p>Plugins are small classes that are used to connect bundles in a flexible and configurable way. In contrast to a direct call to a facade of another module, there can be an array of provided <MadCap:variable name="General.bundles/modules" />.

</p>
        <p>According to our conventions, plugins are the only classes that can be directly instantiated in other modules. For instance the <var>Calculation </var>module uses an array of modules to perform the calculation. A lot of core modules allow to hook into the logic via plugins. This way you can change core behavior without extending core classes and the risk to loose backwards compatibility.

</p>
        <h2>Example: Calculator Plugins
</h2>
        <p>The Calculation module ships with a <var>CalculatorPluginInterface</var> which is implemented in several bundles. For instance you can find the <var>ItemTaxCalculatorPlugin</var> inside the Tax module.

</p>
        <p>According to the interface, this plugin retrieves a quote transfer object, performs tax related calculations and adds them to the quote.

</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Spryker\Zed\Tax\Communication\Plugin;

use Generated\Shared\Transfer\QuoteTransfer;
use Spryker\Zed\Calculation\Dependency\Plugin\CalculatorPluginInterface;
use Spryker\Zed\Kernel\Communication\AbstractPlugin;

/**
 * @method \Spryker\Zed\Tax\Business\TaxFacade getFacade()
 * @method \Spryker\Zed\Tax\Communication\TaxCommunicationFactory getFactory()
 */
class ItemTaxCalculatorPlugin extends AbstractPlugin implements CalculatorPluginInterface
{

    /**
     * This plugin makes calculations based on the given quote. The result is added to the quote.
     *
     * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer
     *
     * @return void
     */
    public function recalculate(QuoteTransfer $quoteTransfer)
    {
        $this-&gt;getFacade()-&gt;recalculateTaxItemAmount($quoteTransfer);
    }

}
</code></pre>
        <h2>How to implement a plugin
</h2>
        <p>A plugin always implements an interface which is stored in the consuming module. You can find them in the <var>[PROJECT]\[APPLICATION]\[module]\Dependency\Plugin </var>namespace (e.g. <var>Spryker\Zed\Calculation\Dependency\Plugin</var>).
module</p>
        <p>
Your new plugin needs to be placed in a specific directory inside your module:
</p>
        <table style="width: 100%;mc-table-style: url('../Resources/TableStyles/PatternedRows.css');" class="TableStyle-PatternedRows" cellspacing="0">
            <col class="TableStyle-PatternedRows-Column-Regular" />
            <col class="TableStyle-PatternedRows-Column-Regular" />
            <col class="TableStyle-PatternedRows-Column-Regular" />
            <thead>
                <tr class="TableStyle-PatternedRows-Head-Header1">
                    <th class="TableStyle-PatternedRows-HeadE-Regular-Header1">Application	</th>
                    <th class="TableStyle-PatternedRows-HeadE-Regular-Header1">Plugin directory</th>
                    <th class="TableStyle-PatternedRows-HeadD-Regular-Header1">Example
</th>
                </tr>
            </thead>
            <tbody>
                <tr class="TableStyle-PatternedRows-Body-LightRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-LightRows">Client	</td>
                    <td class="TableStyle-PatternedRows-BodyE-Regular-LightRows">	[PROJECT]\Client\[module]\Plugin\	</td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-LightRows">Pyz\Client\Catalog\Plugin\Config\CatalogSearchConfigBuilder</td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-DarkerRows">
                    <td class="TableStyle-PatternedRows-BodyE-Regular-DarkerRows">Yves	</td>
                    <td class="TableStyle-PatternedRows-BodyE-Regular-DarkerRows">[PROJECT]\Yves\[module]\Plugin\	</td>
                    <td class="TableStyle-PatternedRows-BodyD-Regular-DarkerRows">Pyz\Yves\Cart\Plugin\Provider\CartControllerProvider</td>
                </tr>
                <tr class="TableStyle-PatternedRows-Body-LightRows">
                    <td class="TableStyle-PatternedRows-BodyB-Regular-LightRows">Zed	</td>
                    <td class="TableStyle-PatternedRows-BodyB-Regular-LightRows">

[PROJECT]\Zed\[module]\Communication\Plugin\</td>
                    <td class="TableStyle-PatternedRows-BodyA-Regular-LightRows">	Spryker\Zed\Tax\Communication\Plugin\ItemTaxCalculatorPlugin</td>
                </tr>
            </tbody>
        </table>
        <p>Plugins delegate calls to the underlying code of the same module. Plugins usually need to extend an <var>AbstractPlugin</var>. This way they can access the internal classes of their module. We recommend to use the <var>@method</var> doc block notation to enable auto completion in the IDE.

</p>
        <h3>Plugins in Zed
</h3>
        <p>You can copy and paste the template below. All you need to do is to replace the placeholders and to implement the related interface. The <var>AbstractPlugin </var>allows you to access the facade of the module where the plugin is placed via the <var>getFacade()</var> method.

</p>
        <p>The most common use case for plugins in Zed is to delegate all calls directly to a method in the facade. You can also access the factory of the communication layer via <var>getFactory()</var> and it is also possible to access the query container via <var>getQueryContainer() </var>but in general this should not be neccessary.

</p><pre><code class="language-PHP line-numbers">&lt;?php
namepace Pyz\Zed\[BUNDLE]\Communication\Plugin;

use Spryker\Zed\Kernel\Communication\AbstractPlugin;

/**
 * @method \Spryker\Zed\[module]\Business\[module]Facade getFacade()
 */
class [PLUGIN]Plugin extends AbstractPlugin implements AnotherBundlePluginInterface
{ 
    // ...
}
</code></pre>
        <h3>Plugins in Yves
</h3>
        <p>You can copy and paste the template below. All you need to do is to replace the placeholders and to implement the related interface. The <var>AbstractPlugin </var>allows you to access the factory via the <var>getFactory()</var> method.

</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Yves\[BUNDLE]\Plugin;

use Spryker\Yves\Kernel\AbstractPlugin;

/**
 * @method \Spryker\Yves\[BUNDLE]\[BUNDLE]Factory getFactory()
 */
class [PLUGIN]Plugin extends AbstractPlugin implements AnotherBundlePluginInterface
{
    // ...
}
</code></pre>
        <p>In Yves you can find some special plugins. The underlying framework Silex uses special classes like service-providers, controller-providers, routers and twig functions. They are configured in the main <var>YvesBootstrap</var> class. These providers and routers can be provided by several modules, that’s why we place them into the plugin-directory to fit them into our conventions. But they do not necessarily extend the <var>AbstractBundle</var>.

</p>
        <h3>Plugins in Client
</h3>
        <p>You can copy and paste the template below. All you need to do is to replace the placeholders and to implement the related interface. The <var>AbstractPlugin</var> allows you to access the factory via the <var>getFactory()</var> method.

</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Client\[BUNDLE]\Plugin;

use Spryker\Client\Kernel\AbstractPlugin;

/**
 * @method \Spryker\Client\[BUNDLE]\[BUNDLE]Factory getFactory()
 */
class [PLUGIN]Plugin extends AbstractPlugin implements AnotherBundlePluginInterface
{
    // ...
}
</code></pre>
        <h2>How to use a plugin from another module</h2>
        <p>In case you want to make your module flexible, you can add plugins to your module’s dependency provider. To do so you need to define an interface which contains a clear description of the expected implementation in the doc block.

</p>
        <p><b>Example</b>: plugin interface from the Calculation module:</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Zed\Calculation\Dependency\Plugin;

use Generated\Shared\Transfer\QuoteTransfer;

interface CalculatorPluginInterface
{

    /**
     * This plugin makes calculations based on the given quote. The result is added to the quote.
     *
     * @param \Generated\Shared\Transfer\QuoteTransfer $quoteTransfer
     *
     * @return void
     */
    public function recalculate(QuoteTransfer $quoteTransfer);

}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <p>
Now you can provide the plugin or an array of plugins in the dependency provider, as in the example below.

Example of dependency provider from the <var>Calculation </var> module:

</p><pre><code class="language-PHP line-numbers">
&lt;?php
class CalculationDependencyProvider extends AbstractBundleDependencyProvider
{

    const CALCULATOR_STACK = 'calculator stack';

    /**
     * @param \Spryker\Zed\Kernel\Container $container
     *
     * @return \Spryker\Zed\Kernel\Container
     */
    public function provideBusinessLayerDependencies(Container $container)
    {
        $container[static::CALCULATOR_STACK] = function (Container $container) {
            return $this-&gt;getCalculatorStack($container);
        };

        return $container;
    }

    /**
     * @param \Spryker\Zed\Kernel\Container $container
     *
     * @return \Spryker\Zed\Calculation\Dependency\Plugin\CalculatorPluginInterface[]
     */
    protected function getCalculatorStack(Container $container)
    {
        return [
            //Remove calculated values, start with clean state.
            new RemoveTotalsCalculatorPlugin(),

            //Item calculators
            new ProductOptionGrossSumCalculatorPlugin(),
            new ItemGrossAmountsCalculatorPlugin(),

            //SubTotal
            new SubtotalTotalsCalculatorPlugin(),

            //Expenses (e.g. shipping)
            new ExpensesGrossSumAmountCalculatorPlugin(),
            new ExpenseTotalsCalculatorPlugin(),

            //GrandTotal
            new GrandTotalTotalsCalculatorPlugin(),
        ];
    }

}
</code></pre>
    </body>
</html>