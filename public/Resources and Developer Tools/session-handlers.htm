<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="4" MadCap:lastHeight="24427" MadCap:lastWidth="574" style="">
    <head>
    </head>
    <body>
        <h1>Session Handlers</h1>
        <p>We provide a number of session handlers to work with different storages. By default, the demo-shop uses a locking Redis session handler for <i>Yves</i> and a non-locking Redis session handler for <i>Zed</i> in the development environment.

</p>
        <p>The following session handlers are currently available:

</p>
        <ul>
            <li class="bullet_list">File
</li>
            <li class="bullet_list">Couchbase
</li>
            <li class="bullet_list">MySql
</li>
            <li class="bullet_list">Redis
</li>
            <li class="bullet_list">Redis (locking)
</li>
        </ul>
        <p>You can easily create and add your own.

</p>
        <h2>Changing The Session Handler

</h2>
        <p>Session handlers can be configured per environment using one of the configuration files in .<var>/config/Shared/. </var>It requires setting <var>\Spryker\Shared\Session\SessionConstants::YVES_SESSION_SAVE_HANDLER</var> to one of the supported session handlers (please see <var>\Spryker\Shared\Session\SessionConstants</var> for a list of all supported session handlers).

</p>
        <h2>Locked Sessions with Redis

</h2>
        <p>Redis doesn't support locking mechanisms for storage keys out of the box. We provide a dedicated session handler that adds a locking strategy and prevents concurrent access to session data. While this strategy ensures data integrity, it comes at a cost.
</p>
        <h2>
Concurrent Requests

</h2>
        <p>The locking strategy will acquire an exclusive lock on the session as soon as the session data is read. This happens for each request while the application is bootstrapping. Since only one request can hold a lock to the same session at a time, concurrent access to this session will result in subsequent requests waiting to acquire a lock. This might not be desirable for concurrent AJAX requests that don't even require access to session data. To work around that issue it is possible to immediately close a session from a controller using <var><a href="http://php.net/manual/en/function.session-write-close.php" target="_blank">PHP's session_write_close()</a></var>. This will immediately close the session and release the lock.

</p>
        <h2>Performance

</h2>
        <p>Checking locks, setting locks, and removing locks requires additional requests to Redis that might have an impact on performance. If performance is crucial and session data integrity violations can be handled, our  Redis session handler doesn't lock and doesn't bring the overhead of handling locks. However, we highly recommend using the locking Redis session handler to keep the integrity of session data.
</p>
        <h2>
Using a Cluster

</h2>
        <p>The current locking strategy doesn't provide support for ensuring locks across a cluster of Redis nodes. Since Redis clusters for session storage are not very common and ensuring locks across a cluster involves even more requests to Redis, not yet supported.</p>
    </body>
</html>