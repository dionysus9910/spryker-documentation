<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" style="" MadCap:conditions="General.Draft">
    <head>
    </head>
    <body>
        <h1>Dependency Injector</h1>
        <p MadCap:conditions="General.Hidden Comment">http://spryker.github.io/development-guide/reference/dependency-injector/</p>
        <p MadCap:conditions="General.Hidden Comment">Andrey Tkachenko: that page is super old, and is outdated for about 2 years...</p>
        <p>The <a href="dependency-provider.htm" target="_blank">Dependency Provider</a> defines which “external dependencies” you need to retrieve(e.g. a facade of another module).
</p>
        <p>
The <var>DependencyInjector</var> is the opposite of it. This class will push dependencies into another module without the need to touch the module where it injects to (<a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank">OCP</a>).

</p>
        <p>For instance, let’s consider you have a module that handles the integration with a payment service(e.g. Payolution). In order to make this payment option available, you need to inject some functionality from this module into the Checkout. To achieve this you need to consider the following aspects:

</p>
        <ul>
            <li class="bullet_list">A <var>DependencyProvider</var> with defined hooks.
</li>
            <li class="bullet_list">A <var>DependencyInjector</var> that injects the functionality.
</li>
            <li class="bullet_list">Configure from which <MadCap:variable name="General.bundles/modules" /> the functionality should be injected to which module.
</li>
        </ul>
        <h2>Dependency Injectors
</h2>
        <p>
This technique of injecting dependencies can be used both in Yves and Zed.
</p>
        <p><b>Example</b>:
</p>
        <p>
You can see in the example below the dependency provider from the <var>Checkout </var> module.

</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Spryker\Yves\Checkout;

use Spryker\Yves\Kernel\AbstractBundleDependencyProvider;
use Spryker\Yves\Kernel\Container;
use Spryker\Yves\StepEngine\Dependency\Plugin\StepHandlerPluginCollection;
use Spryker\Yves\StepEngine\Dependency\Plugin\SubFormPluginCollection;

class CheckoutDependencyProvider extends AbstractBundleDependencyProvider
{
    const PAYMENT_METHOD_HANDLER = 'payment method handler';
    const PAYMENT_SUB_FORMS = 'payment sub forms';

    /**
     * @param \Spryker\Yves\Kernel\Container $container
     *
     * @return \Spryker\Yves\Kernel\Container
     */
    public function provideDependencies(Container $container)
    {
        $container[static::PAYMENT_SUB_FORMS] = function () {
            return new SubFormPluginCollection();
        };

        $container[static::PAYMENT_METHOD_HANDLER] = function () {
            return new StepHandlerPluginCollection();
        };

        return $container;
    }

}</code></pre>
        <p>The DependencyProvider defines some hooks in the container, which then can be used to inject additional functionality to them.
</p>
        <p>
In our example, we want to add <var>Payolution </var>as a payment option in checkout but without making any modifications in the <var>Checkout </var>module. We want to extend the functionality from the <var>Checkout </var>by adding this payment option.

</p>
        <p>The <var>Checkout </var> module has the knowledge on how to handle the process that starts after a new order is submitted; the <var>Checkout </var> module doesn’t need to know details regarding which payment or delivery methods are available.

</p>
        <p>This functionality is injected by implementing a <var>DependencyInjectorInterface</var> in the module that does the integration with the payment service(<var>Payolution </var>in our case). The dependencies defined in the dependency provider from the <var>Checkout </var> module are then extended with the required functionality.
</p>
        <MadCap:dropDown>
            <MadCap:dropDownHead>
                <MadCap:dropDownHotspot>Click to expand the code sample)</MadCap:dropDownHotspot>
            </MadCap:dropDownHead>
            <MadCap:dropDownBody><pre><code class="language-PHP line-numbers">&lt;?php
namespace Spryker\Yves\Payolution\Dependency\Injector;

use Spryker\Shared\Kernel\ContainerInterface;
use Spryker\Yves\CheckoutStepEngine\CheckoutDependencyProvider;
use Spryker\Yves\CheckoutStepEngine\Dependency\Plugin\CheckoutStepHandlerPluginCollection;
use Spryker\Yves\CheckoutStepEngine\Dependency\Plugin\CheckoutSubFormPluginCollection;
use Spryker\Yves\Kernel\Dependency\Injector\AbstractDependencyInjector;

class CheckoutDependencyInjector extends AbstractDependencyInjector
{

    /**
     * @param \Spryker\Shared\Kernel\ContainerInterface|\Spryker\Yves\Kernel\Container $container
     *
     * @return \Spryker\Shared\Kernel\ContainerInterface|\Spryker\Yves\Kernel\Container
     */
    public function inject(ContainerInterface $container)
    {
        $container-&gt;extend(CheckoutDependencyProvider::PAYMENT_SUB_FORMS, function (CheckoutSubFormPluginCollection $paymentSubForms) {
            $paymentSubForms-&gt;add(...);

            return $paymentSubForms;
        });

        $container-&gt;extend(CheckoutDependencyProvider::PAYMENT_METHOD_HANDLER, function (CheckoutStepHandlerPluginCollection $paymentMethodHandler) {
            $paymentMethodHandler-&gt;add(...);

            return $paymentMethodHandler;
        });

        return $container;
    }

}</code></pre>
            </MadCap:dropDownBody>
        </MadCap:dropDown>
        <h2>Naming

</h2>
        <p>The class name is important for resolving. The dependency injector resolver will always look for a class named like <var>Namespace\Application\(InjectFromBundle)\Dependency\Injector\(InjectToBundle)DependencyInjector</var>.</p><pre><code class="language-PHP line-numbers">&lt;?php
...
$config[KernelConstants::DEPENDENCY_INJECTOR_YVES] = [
    'Checkout' =&gt; [ // bundle to inject to
        'Payolution', // bundle which injects functionality
        '...'
    ]
];

$config[KernelConstants::DEPENDENCY_INJECTOR_ZED] = [
    ...
];
...</code></pre>
        <p>More <MadCap:variable name="General.bundles/modules" /> can inject functionality into the same module. There is no limitation on this matter.
</p>
        <p>
In our example, you can have more <MadCap:variable name="General.bundles/modules" /> that integrate with payment providers and from each of them you can inject functionality into the <var>Checkout</var>.

</p>
        <h2>How to use the injected functionality?
</h2>
        <p>Inside the <a href="factory.htm" target="_blank">Factory</a> you can simply use your defined dependency. When nothing is injected you will only get what you have defined in your dependency provider, in this example an empty collection. But you also can define some defaults that you want to use.

</p>
        <p>The injector just adds more functionality.

</p><pre><code class="language-PHP line-numbers">&lt;?php
namespace Pyz\Yves\Checkout\Form;

use Spryker\Yves\Checkout\CheckoutDependencyProvider;
use Spryker\Yves\Kernel\AbstractFactory;

class FormFactory extends AbstractFactory
{

    /**
     * @return \Spryker\Yves\StepEngine\Dependency\Plugin\Form\SubFormPluginCollection
     */
    protected function createPaymentMethodSubForms()
    {
        return $this-&gt;getProvidedDependency(CheckoutDependencyProvider::PAYMENT_SUB_FORMS);
    }

}</code></pre>
    </body>
</html>